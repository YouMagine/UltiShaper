// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(function(require) {
    var $, GlThreeView, MyAxisHelper, THREE, combo_cam, csg, detector, marionette, orbit_ctrl, requestAnimationFrame, stats, threedView_template, utils;
    $ = require('jquery');
    marionette = require('marionette');
    csg = require('csg');
    THREE = require('three');
    THREE.CSG = require('three_csg');
    combo_cam = require('combo_cam');
    detector = require('detector');
    stats = require('stats');
    utils = require('utils');
    threedView_template = require("text!templates/glThree.tmpl");
    requestAnimationFrame = require('anim');
    orbit_ctrl = require('orbit_ctrl');
    MyAxisHelper = (function() {

      function MyAxisHelper(size, xcolor, ycolor, zcolor) {
        var geometry, material;
        geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(-size || -1, 0, 0), new THREE.Vector3(size || 1, 0, 0), new THREE.Vector3(0, -size || -1, 0), new THREE.Vector3(0, size || 1, 0), new THREE.Vector3(0, 0, -size || -1), new THREE.Vector3(0, 0, size || 1));
        geometry.colors.push(xcolor || new THREE.Color(0xffaa00), xcolor || new THREE.Color(0xffaa00), ycolor || new THREE.Color(0xaaff00), ycolor || new THREE.Color(0xaaff00), zcolor || new THREE.Color(0x00aaff), zcolor || new THREE.Color(0x00aaff));
        material = new THREE.LineBasicMaterial({
          vertexColors: THREE.VertexColors,
          linewidth: 1
        });
        return new THREE.Line(geometry, material, THREE.LinePieces);
      }

      return MyAxisHelper;

    })();
    GlThreeView = (function(_super) {

      __extends(GlThreeView, _super);

      GlThreeView.prototype.template = threedView_template;

      GlThreeView.prototype.ui = {
        renderBlock: "#glArea",
        glOverlayBlock: "#glOverlay",
        overlayDiv: "#overlay"
      };

      GlThreeView.prototype.events = {
        'contextmenu': 'rightclick',
        "mousedown .toggleGrid": "toggleGrid",
        "mousedown .toggleAxes": "toggleAxes",
        "mousedown .toggleShadows": "toggleShadows",
        "mousedown .toggleAA": "toggleAA",
        "mousedown .toggleAutoUpdate": "toggleAutoUpdate"
      };

      /*
          triggers: 
            "mousedown .toggleGrid":    "toggleGrid:mousedown"
            "mousedown .toggleAxes":    "toggleAxes:mousedown"
            "mousedown .toggleShadows": "toggleShadows:mousedown"
            "mousedown .toggleAA":      "toggleAA:mousedown"
      */


      GlThreeView.prototype.toggleGrid = function(ev) {
        var toggled;
        toggled = this.settings.get("showGrid");
        if (toggled) {
          this.settings.set("showGrid", false);
          $(ev.target).addClass("uicon-off");
        } else {
          this.settings.set("showGrid", true);
          $(ev.target).removeClass("uicon-off");
        }
        return false;
      };

      GlThreeView.prototype.toggleAxes = function(ev) {
        var toggled;
        toggled = this.settings.get("showAxes");
        if (toggled) {
          this.settings.set("showAxes", false);
          $(ev.target).addClass("uicon-off");
        } else {
          this.settings.set("showAxes", true);
          $(ev.target).removeClass("uicon-off");
        }
        return false;
      };

      GlThreeView.prototype.toggleShadows = function(ev) {
        var toggled;
        toggled = this.settings.get("shadows");
        if (toggled) {
          this.settings.set("shadows", false);
          $(ev.target).addClass("uicon-off");
        } else {
          this.settings.set("shadows", true);
          $(ev.target).removeClass("uicon-off");
        }
        return false;
      };

      GlThreeView.prototype.toggleAA = function(ev) {
        var toggled;
        toggled = this.settings.get("antialiasing");
        if (toggled) {
          this.settings.set("antialiasing", false);
          $(ev.target).addClass("uicon-off");
        } else {
          this.settings.set("antialiasing", true);
          $(ev.target).removeClass("uicon-off");
        }
        return false;
      };

      GlThreeView.prototype.toggleAutoUpdate = function(ev) {
        var toggled;
        toggled = this.settings.get("autoUpdate");
        if (toggled) {
          this.settings.set("autoUpdate", false);
          $(ev.target).addClass("uicon-off");
        } else {
          this.settings.set("autoUpdate", true);
          $(ev.target).removeClass("uicon-off");
        }
        return false;
      };

      GlThreeView.prototype.rightclick = function(ev) {
        var x, y;
        normalizeEvent(ev);
        x = ev.offsetX;
        y = ev.offsetY;
        this.selectObj(x, y);
        ev.preventDefault();
        return false;
      };

      GlThreeView.prototype.mousewheel = function(ev) {
        var wheelDelta;
        ev = window.event || ev;
        wheelDelta = null;
        if (ev.originalEvent != null) {
          wheelDelta = ev.originalEvent.detail != null ? ev.originalEvent.detail * (-120) : void 0;
        } else {
          wheelDelta = ev.wheelDelta;
        }
        return console.log("tet" + wheelDelta);
        /*
              if wheelDelta > 0
                @controls.zoomOut()
              else 
                @controls.zoomIn()
              ev.preventDefault()
              ev.stopPropagation()
              return false
        */

        /*ev = window.event or ev; # old IE support  
        #@controls.onMouseWheel(ev)
        delta = Math.max(-1, Math.min(1, (ev.wheelDelta or -ev.detail)))
        delta*=75
        if delta - @camera.position.z <= 100
          @camera.position.z-=delta
        return false
        */

      };

      GlThreeView.prototype.mousemove = function(ev) {
        /*if @dragStart?
          moveMinMax = 10
          
          @dragAmount=[@dragStart.x-ev.offsetX, @dragStart.y-ev.offsetY]
          #@dragAmount[1]=@height-@dragAmount[1]
          #console.log "bleh #{@dragAmount[0]/500}"
          x_move = Math.max(-moveMinMax, Math.min(moveMinMax, @dragAmount[0]/10))
          y_move = Math.max(-moveMinMax, Math.min(moveMinMax, @dragAmount[1]/10))
          #x_move = (x_move/x_move+0.0001)*moveMinMax
          #y_move = (y_move/y_move+0.0001)*moveMinMax
          #console.log("moving by #{y_move}")
          @camera.position.x+=  x_move #@dragAmount.x/10000
          @camera.position.y-=  y_move#@dragAmount.y/100
          return false
        */

      };

      GlThreeView.prototype.dragstart = function(ev) {
        return this.dragStart = {
          'x': ev.offsetX,
          'y': ev.offsetY
        };
      };

      GlThreeView.prototype.mouseup = function(ev) {};

      GlThreeView.prototype.mousedown = function(ev) {};

      GlThreeView.prototype.selectObj = function(mouseX, mouseY) {
        var draw_impact, intersects, newMat, ray, reset_col, v,
          _this = this;
        v = new THREE.Vector3((mouseX / this.width) * 2 - 1, -(mouseY / this.height) * 2 + 1, 0.5);
        this.projector.unprojectVector(v, this.camera);
        ray = new THREE.Ray(this.camera.position, v.subSelf(this.camera.position).normalize());
        intersects = ray.intersectObjects(this.controller.objects);
        reset_col = function() {
          if (_this.current != null) {
            _this.current.material = _this.current.origMaterial;
            if (_this.current.cageView != null) {
              _this.scene.remove(_this.current.cageView);
            }
            return _this.current = null;
          }
        };
        draw_impact = function(position) {
          var sprite;
          sprite = new THREE.Sprite({
            map: _this.particleTexture,
            transparent: true,
            useScreenCoordinates: false,
            scaleByViewport: false
          });
          sprite.position = position;
          return _this.scene.add(sprite);
        };
        if (intersects != null) {
          if (intersects.length > 0) {
            if (intersects[0].object.name !== "workplane") {
              if (this.current !== intersects[0].object) {
                this.current = intersects[0].object;
                newMat = new THREE.MeshLambertMaterial({
                  color: 0xCC0000
                });
                this.current.origMaterial = this.current.material;
                this.current.material = newMat;
                this.addCage(this.current);
                if (this.current.cageView != null) {
                  this.scene.add(this.current.cageView);
                }
              }
            } else {
              reset_col();
            }
          } else {
            reset_col();
          }
        } else {
          reset_col();
        }
        return this._render();
      };

      GlThreeView.prototype.switchModel = function(newModel) {
        this.scene.remove(this.mesh);
        try {
          this.scene.remove(this.current.cageView);
          this.current = null;
        } catch (_error) {}
        this.controller.objects = [];
        this.model = newModel;
        this.bindTo(this.model, "change", this.modelChanged);
        return this.fromCsg(this.model);
      };

      GlThreeView.prototype.modelChanged = function(model, value) {
        var callback,
          _this = this;
        switch (this.settings.get("csgRenderMode")) {
          case "onCodeChange":
            return this.fromCsg(this.model);
          case "onCodeChangeDelayed":
            if (this.CodeChangeTimer) {
              clearTimeout(this.CodeChangeTimer);
              this.CodeChangeTimer = null;
            }
            callback = function() {
              return _this.fromCsg(_this.model);
            };
            return this.CodeChangeTimer = setTimeout(callback, this.settings.get("csgRenderDelay") * 1000);
        }
      };

      GlThreeView.prototype.modelSaved = function(model) {
        return this.fromCsg(this.model);
      };

      GlThreeView.prototype.settingsChanged = function(settings, value) {
        var key, offset, tgt, val, _ref,
          _this = this;
        _ref = this.settings.changedAttributes();
        for (key in _ref) {
          val = _ref[key];
          switch (key) {
            case "bgColor":
              this.setBgColor();
              break;
            case "bgColor2":
              this.setBgColor();
              break;
            case "renderer":
              delete this.renderer;
              this.init();
              this.fromCsg(this.model);
              this.render();
              break;
            case "csgRenderMode":
              switch (val) {
                case "onCodeChange":
                  console.log("onCodeChange");
                  if (this.modelSaveBinding != null) {
                    this.unbindFrom(this.modelSaveBinding);
                  }
                  this.modelChangeBinding = this.bindTo(this.model, "change", this.modelChanged);
                  this.fromCsg(this.model);
                  break;
                case "onCodeChangeDelayed":
                  console.log("onCodeChangeDelayed");
                  if (this.modelSaveBinding != null) {
                    this.unbindFrom(this.modelSaveBinding);
                  }
                  this.modelChangeBinding = this.bindTo(this.model, "change", this.modelChanged);
                  this.fromCsg(this.model);
                  break;
                case "onDemand":
                  if (this.modelChangeBinding != null) {
                    this.unbindFrom(this.modelChangeBinding);
                  }
                  if (this.modelSaveBinding != null) {
                    this.unbindFrom(this.modelSaveBinding);
                  }
                  this.app.vent.bind("parseCsgRequest", function() {
                    return _this.fromCsg(_this.model);
                  });
                  break;
                case "onSave":
                  if (this.modelChangeBinding != null) {
                    this.unbindFrom(this.modelChangeBinding);
                  }
                  this.modelSaveBinding = this.bindTo(this.model, "saved", this.modelSaved);
              }
              break;
            case "showGrid":
              if (val) {
                this.addGrid();
              } else {
                this.removeGrid();
              }
              break;
            case "gridSize":
              if (this.grid != null) {
                this.removeGrid();
                this.addGrid();
              }
              break;
            case "gridStep":
              if (this.grid != null) {
                this.removeGrid();
                this.addGrid();
              }
              break;
            case "gridColor":
              if (this.grid != null) {
                this.grid.material.color.setHex(val);
                this.subGrid.material.color.setHex(val);
              }
              break;
            case "gridOpacity":
              if (this.grid != null) {
                this.grid.material.opacity = val;
                this.subGrid.material.opacity = val;
              }
              break;
            case "showAxes":
              if (val) {
                this.addAxes();
              } else {
                this.removeAxes();
              }
              break;
            case "shadows":
              if (!val) {
                this.renderer.clearTarget(this.light.shadowMap);
                this.fromCsg(this.model);
                this.render();
                this.renderer.shadowMapAutoUpdate = false;
                if (this.settings.get("showGrid")) {
                  this.removeGrid();
                  this.addGrid();
                }
              } else {
                this.renderer.shadowMapAutoUpdate = true;
                this.fromCsg(this.model);
                this.render();
                if (this.settings.get("showGrid")) {
                  this.removeGrid();
                  this.addGrid();
                }
              }
              break;
            case "selfShadows":
              this.fromCsg(this.model);
              this.render();
              break;
            case "showStats":
              if (val) {
                this.ui.overlayDiv.append(this.stats.domElement);
              } else {
                $(this.stats.domElement).remove();
              }
              break;
            case "projection":
              if (val === "orthographic") {
                this.camera.toOrthographic();
              } else {
                this.camera.toPerspective();
                this.camera.setZoom(1);
              }
              break;
            case "position":
              this.setupView(val);
              break;
            case "wireframe":
              if (this.mesh != null) {
                this.mesh.material.wireframe = val;
              }
              break;
            case 'center':
              try {
                tgt = this.controls.target;
                offset = new THREE.Vector3().subSelf(this.controls.target.clone());
                this.controls.target.addSelf(offset);
                this.camera.position.addSelf(offset);
              } catch (error) {
                console.log("error " + error + " in center");
              }
              this.camera.lookAt(this.scene.position);
              break;
            case 'helpersColor':
              if (this.axes != null) {
                this.axes.material.color.setHex(val);
              }
          }
        }
        return this._render();
      };

      function GlThreeView(options, settings) {
        this.addObjs = __bind(this.addObjs, this);

        this.fromCsg = __bind(this.fromCsg, this);

        this.animate = __bind(this.animate, this);

        this._render = __bind(this._render, this);

        this.onRender = __bind(this.onRender, this);

        this.onResize = __bind(this.onResize, this);

        this.drawText2 = __bind(this.drawText2, this);

        this.drawText = __bind(this.drawText, this);

        this.addCage = __bind(this.addCage, this);

        this.removeGrid = __bind(this.removeGrid, this);

        this.addGrid = __bind(this.addGrid, this);

        this.setBgColor = __bind(this.setBgColor, this);

        this.setupView = __bind(this.setupView, this);

        this.setupLights = __bind(this.setupLights, this);

        this.configure = __bind(this.configure, this);

        this.init = __bind(this.init, this);

        this.settingsChanged = __bind(this.settingsChanged, this);

        this.modelSaved = __bind(this.modelSaved, this);

        this.modelChanged = __bind(this.modelChanged, this);

        this.selectObj = __bind(this.selectObj, this);

        this.mousedown = __bind(this.mousedown, this);

        this.mouseup = __bind(this.mouseup, this);

        this.dragstart = __bind(this.dragstart, this);

        this.mousewheel = __bind(this.mousewheel, this);

        this.rightclick = __bind(this.rightclick, this);

        this.toggleAutoUpdate = __bind(this.toggleAutoUpdate, this);

        this.toggleAA = __bind(this.toggleAA, this);

        this.toggleShadows = __bind(this.toggleShadows, this);

        this.toggleAxes = __bind(this.toggleAxes, this);

        this.toggleGrid = __bind(this.toggleGrid, this);
        GlThreeView.__super__.constructor.call(this, options);
        this.settings = options.settings;
        this.app = require('app');
        this.stats = new stats();
        this.stats.domElement.style.position = 'absolute';
        this.stats.domElement.style.top = '30px';
        this.stats.domElement.style.zIndex = 100;
        this.bindTo(this.settings, "change", this.settingsChanged);
        this.dragging = false;
        this.width = 800;
        this.height = 600;
        this.init();
      }

      GlThreeView.prototype.init = function() {
        var csgRenderMode, val,
          _this = this;
        this.renderer = null;
        this.configure(this.settings);
        this.renderer.shadowMapEnabled = true;
        this.renderer.shadowMapAutoUpdate = true;
        this.controller = new THREE.Object3D();
        this.controller.name = "picker";
        this.controller.objects = [];
        this.projector = new THREE.Projector();
        this.setupScene();
        this.setupOverlayScene();
        this.setBgColor();
        csgRenderMode = this.settings.get("csgRenderMode");
        switch (csgRenderMode) {
          case "onCodeChange":
            console.log("onCodeChange");
            if (this.modelSaveBinding != null) {
              unbindFrom(this.modelSaveBinding);
            }
            this.modelChangeBinding = this.bindTo(this.model, "change", this.modelChanged);
            break;
          case "onCodeChangeDelayed":
            console.log("onCodeChangeDelayed");
            if (this.modelSaveBinding != null) {
              unbindFrom(this.modelSaveBinding);
            }
            this.modelChangeBinding = this.bindTo(this.model, "change", this.modelChanged);
            break;
          case "onDemand":
            if (this.modelChangeBinding != null) {
              unbindFrom(this.modelChangeBinding);
            }
            if (this.modelSaveBinding != null) {
              unbindFrom(this.modelSaveBinding);
            }
            this.app.vent.bind("parseCsgRequest", function() {
              return _this.fromCsg(_this.model);
            });
            break;
          case "onSave":
            if (this.modelChangeBinding != null) {
              unbindFrom(this.modelChangeBinding);
            }
            this.modelSaveBinding = this.bindTo(this.model, "saved", this.modelSaved);
        }
        if (this.settings.get("shadows")) {
          this.renderer.shadowMapAutoUpdate = this.settings.get("shadows");
        }
        if (this.settings.get("showGrid")) {
          this.addGrid();
        }
        if (this.settings.get("showAxes")) {
          this.addAxes();
        }
        if (this.settings.get("projection") === "orthographic") {
          this.camera.toOrthographic();
          this.camera.setZoom(6);
        } else {
          this.camera.toPerspective();
        }
        if (this.mesh != null) {
          this.mesh.material.wireframe = this.settings.get("wireframe");
        }
        val = this.settings.get("position");
        return this.setupView(val);
      };

      GlThreeView.prototype.configure = function(settings) {
        var renderer;
        if (settings.get("renderer")) {
          renderer = settings.get("renderer");
          if (renderer === "webgl") {
            if (detector.webgl) {
              console.log("Gl Renderer");
              this.renderer = new THREE.WebGLRenderer({
                clearColor: 0x00000000,
                clearAlpha: 0,
                antialias: true
              });
              this.renderer.clear();
              this.renderer.setSize(this.width, this.height);
              this.overlayRenderer = new THREE.WebGLRenderer({
                clearColor: 0x000000,
                clearAlpha: 0,
                antialias: true
              });
              return this.overlayRenderer.setSize(350, 250);
            } else if (!detector.webgl && !detector.canvas) {
              return console.log("No Webgl and no canvas (fallback) support, cannot render");
            } else if (!detector.webgl && detector.canvas) {
              this.renderer = new THREE.CanvasRenderer({
                clearColor: 0x00000000,
                clearAlpha: 0,
                antialias: true
              });
              this.renderer.clear();
              this.overlayRenderer = new THREE.CanvasRenderer({
                clearColor: 0x000000,
                clearAlpha: 0,
                antialias: true
              });
              this.overlayRenderer.setSize(350, 250);
              return this.renderer.setSize(this.width, this.height);
            } else {
              return console.log("No Webgl and no canvas (fallback) support, cannot render");
            }
          } else if (renderer === "canvas") {
            if (detector.canvas) {
              this.renderer = new THREE.CanvasRenderer({
                clearColor: 0x00000000,
                clearAlpha: 0,
                antialias: true
              });
              this.renderer.clear();
              this.overlayRenderer = new THREE.CanvasRenderer({
                clearColor: 0x000000,
                clearAlpha: 0,
                antialias: true
              });
              this.overlayRenderer.setSize(350, 250);
              return this.renderer.setSize(this.width, this.height);
            } else if (!detector.canvas) {
              return console.log("No canvas support, cannot render");
            }
          }
        }
      };

      GlThreeView.prototype.setupScene = function() {
        var ASPECT, FAR, NEAR;
        this.viewAngle = 45;
        ASPECT = this.width / this.height;
        NEAR = 0.1;
        FAR = 10000;
        /* 
        @camera =
        new THREE.PerspectiveCamera(
            @viewAngle,
            ASPECT,
            NEAR,
            FAR)
        */

        this.camera = new THREE.CombinedCamera(this.width, this.height, this.viewAngle, NEAR, FAR, NEAR, FAR);
        this.camera.up = new THREE.Vector3(0, 0, 1);
        this.camera.position.x = 450;
        this.camera.position.y = 450;
        this.camera.position.z = 750;
        this.scene = new THREE.Scene();
        this.scene.add(this.camera);
        this.setupLights();
        return this.cameraHelper = new THREE.CameraHelper(this.camera);
        /*
              xArrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0),new THREE.Vector3(100,0,0),50, 0xFF7700)
              yArrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,1),new THREE.Vector3(100,0,0),50, 0x77FF00)
              zArrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0),new THREE.Vector3(100,0,0),50, 0x0077FF)
              @scene.add xArrow
              @scene.add yArrow
              @scene.add zArrow
        */

      };

      GlThreeView.prototype.setupOverlayScene = function() {
        var ASPECT, FAR, NEAR;
        ASPECT = 350 / 250;
        NEAR = 1;
        FAR = 10000;
        this.overlayCamera = new THREE.CombinedCamera(350, 250, this.viewAngle, NEAR, FAR, NEAR, FAR);
        this.overlayCamera.up = new THREE.Vector3(0, 0, 1);
        this.overlayscene = new THREE.Scene();
        return this.overlayscene.add(this.overlayCamera);
      };

      GlThreeView.prototype.setupLights = function() {
        var ambientLight, pointLight, spotLight;
        pointLight = new THREE.PointLight(0x333333, 5);
        pointLight.position.x = -2200;
        pointLight.position.y = 3000;
        pointLight.position.z = -2200;
        this.ambientColor = '0x253565';
        ambientLight = new THREE.AmbientLight(this.ambientColor);
        spotLight = new THREE.SpotLight(0xbbbbbb, 2);
        spotLight.position.x = 0;
        spotLight.position.y = 0;
        spotLight.position.z = 2000;
        spotLight.castShadow = true;
        this.light = spotLight;
        this.scene.add(ambientLight);
        this.scene.add(pointLight);
        return this.scene.add(spotLight);
      };

      GlThreeView.prototype.setupView = function(val) {
        var nPost, offset, resetCam,
          _this = this;
        resetCam = function() {
          _this.camera.position.z = 0;
          _this.camera.position.y = 0;
          return _this.camera.position.x = 0;
        };
        switch (val) {
          case 'diagonal':
            this.camera.position.x = -450;
            this.camera.position.y = -450;
            this.camera.position.z = 750;
            this.overlayCamera.position.x = -150;
            this.overlayCamera.position.y = -150;
            this.overlayCamera.position.z = 250;
            this.camera.lookAt(this.scene.position);
            this.overlayCamera.lookAt(this.overlayscene.position);
            break;
          case 'top':
            try {
              offset = this.camera.position.clone().subSelf(this.controls.target);
              nPost = new THREE.Vector3();
              nPost.z = offset.length();
              this.camera.position = nPost;
            } catch (error) {
              this.camera.position = new THREE.Vector3(0, 0, 750);
            }
            this.overlayCamera.position = new THREE.Vector3(0, 0, 250);
            this.camera.lookAt(this.scene.position);
            this.overlayCamera.lookAt(this.overlayscene.position);
            break;
          case 'bottom':
            try {
              offset = this.camera.position.clone().subSelf(this.controls.target);
              nPost = new THREE.Vector3();
              nPost.z = -offset.length();
              this.camera.position = nPost;
            } catch (error) {
              this.camera.position = new THREE.Vector3(0, 0, -750);
            }
            this.overlayCamera.position = new THREE.Vector3(0, 0, -250);
            this.camera.lookAt(this.scene.position);
            this.overlayCamera.lookAt(this.overlayscene.position);
            break;
          case 'front':
            try {
              offset = this.camera.position.clone().subSelf(this.controls.target);
              nPost = new THREE.Vector3();
              nPost.y = -offset.length();
              this.camera.position = nPost;
            } catch (error) {
              this.camera.position = new THREE.Vector3(0, -450, 0);
            }
            this.overlayCamera.position = new THREE.Vector3(0, -250, 0);
            this.camera.lookAt(this.scene.position);
            this.overlayCamera.lookAt(this.overlayscene.position);
            break;
          case 'back':
            try {
              offset = this.camera.position.clone().subSelf(this.controls.target);
              nPost = new THREE.Vector3();
              nPost.y = offset.length();
              this.camera.position = nPost;
            } catch (error) {
              this.camera.position = new THREE.Vector3(0, 450, 0);
            }
            this.overlayCamera.position = new THREE.Vector3(0, 250, 0);
            this.camera.lookAt(this.scene.position);
            this.overlayCamera.lookAt(this.overlayscene.position);
            break;
          case 'left':
            try {
              offset = this.camera.position.clone().subSelf(this.controls.target);
              nPost = new THREE.Vector3();
              nPost.x = offset.length();
              this.camera.position = nPost;
            } catch (error) {
              this.camera.position = new THREE.Vector3(450, 0, 0);
            }
            this.overlayCamera.position = new THREE.Vector3(250, 0, 0);
            this.camera.lookAt(this.scene.position);
            this.overlayCamera.lookAt(this.overlayscene.position);
            break;
          case 'right':
            try {
              offset = this.camera.position.clone().subSelf(this.controls.target);
              nPost = new THREE.Vector3();
              nPost.x = -offset.length();
              this.camera.position = nPost;
            } catch (error) {
              this.camera.position = new THREE.Vector3(-450, 0, 0);
            }
            this.overlayCamera.position = new THREE.Vector3(-250, 0, 0);
            this.camera.lookAt(this.scene.position);
            this.overlayCamera.lookAt(this.overlayscene.position);
        }
        return this._render();
      };

      GlThreeView.prototype.setBgColor = function() {
        var bgColor1, bgColor2;
        console.log("setting bg color");
        bgColor1 = this.settings.get("bgColor");
        bgColor2 = this.settings.get("bgColor2");
        $("body").css("background-color", bgColor1);
        if (bgColor1 !== bgColor2) {
          $("body").css("background-image", "-moz-radial-gradient(center center, circle cover, " + bgColor1 + "," + bgColor2 + "  100%)");
          $("body").css("background-image", "-webkit-radial-gradient(center center, circle cover, " + bgColor1 + "," + bgColor2 + "  100%)");
          $("body").css("background-image", "-o-radial-gradient(center center, circle cover, " + bgColor1 + "," + bgColor2 + "  100%)");
          $("body").css("background-image", "-ms-radial-gradient(center center, circle cover, " + bgColor1 + "," + bgColor2 + "  100%)");
          $("body").css("background-image", "radial-gradient(center center, circle cover, " + bgColor1 + "," + bgColor2 + "  100%)");
          $("body").css("background-repeat", "no-repeat");
          return $("body").css("background-attachment", "fixed");
        } else {
          $("body").css("background-image", "");
          $("body").css("background-image", "");
          $("body").css("background-repeat", "");
          return $("body").css("background-attachment", "");
        }
      };

      GlThreeView.prototype.addGrid = function() {
        /*
              Adds both grid & plane (for shadow casting), based on the parameters from the settings object
        */

        var gridColor, gridGeometry, gridMaterial, gridOpacity, gridSize, gridStep, i, planeFragmentShader, planeGeometry, planeMaterial, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4;
        if (!this.grid) {
          gridSize = this.settings.get("gridSize");
          gridStep = this.settings.get("gridStep");
          gridColor = this.settings.get("gridColor");
          gridOpacity = this.settings.get("gridOpacity");
          gridGeometry = new THREE.Geometry();
          gridMaterial = new THREE.LineBasicMaterial({
            color: new THREE.Color().setHex(gridColor),
            opacity: gridOpacity,
            linewidth: 2,
            transparent: true
          });
          for (i = _i = _ref = -gridSize / 2, _ref1 = gridSize / 2; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _i += gridStep) {
            gridGeometry.vertices.push(new THREE.Vector3(-gridSize / 2, i, 0));
            gridGeometry.vertices.push(new THREE.Vector3(gridSize / 2, i, 0));
            gridGeometry.vertices.push(new THREE.Vector3(i, -gridSize / 2, 0));
            gridGeometry.vertices.push(new THREE.Vector3(i, gridSize / 2, 0));
          }
          this.grid = new THREE.Line(gridGeometry, gridMaterial, THREE.LinePieces);
          this.scene.add(this.grid);
          gridGeometry = new THREE.Geometry();
          gridMaterial = new THREE.LineBasicMaterial({
            color: new THREE.Color().setHex(gridColor),
            opacity: gridOpacity / 2,
            transparent: true
          });
          for (i = _j = _ref2 = -gridSize / 2, _ref3 = gridSize / 2, _ref4 = gridStep / 10; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; i = _j += _ref4) {
            gridGeometry.vertices.push(new THREE.Vector3(-gridSize / 2, i, 0));
            gridGeometry.vertices.push(new THREE.Vector3(gridSize / 2, i, 0));
            gridGeometry.vertices.push(new THREE.Vector3(i, -gridSize / 2, 0));
            gridGeometry.vertices.push(new THREE.Vector3(i, gridSize / 2, 0));
          }
          this.subGrid = new THREE.Line(gridGeometry, gridMaterial, THREE.LinePieces);
          this.scene.add(this.subGrid);
          planeGeometry = new THREE.PlaneGeometry(-gridSize, gridSize, 5, 5);
          planeFragmentShader = ["uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], "void main() {", "gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 );", THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 - shadowColor.x );", "}"].join("\n");
          planeMaterial = new THREE.ShaderMaterial({
            uniforms: THREE.ShaderLib['basic'].uniforms,
            vertexShader: THREE.ShaderLib['basic'].vertexShader,
            fragmentShader: planeFragmentShader,
            color: 0x0000FF,
            transparent: true
          });
          this.plane = new THREE.Mesh(planeGeometry, planeMaterial);
          this.plane.rotation.x = Math.PI;
          this.plane.position.z = -2;
          this.plane.name = "workplane";
          this.plane.receiveShadow = true;
          return this.scene.add(this.plane);
        }
      };

      GlThreeView.prototype.removeGrid = function() {
        if (this.grid) {
          this.scene.remove(this.plane);
          this.scene.remove(this.grid);
          this.scene.remove(this.subGrid);
          delete this.grid;
          delete this.subGrid;
          return delete this.plane;
        }
      };

      GlThreeView.prototype.addAxes = function() {
        var helpersColor;
        helpersColor = this.settings.get("helpersColor");
        helpersColor = new THREE.Color().setHex(helpersColor);
        this.axes = new MyAxisHelper(200, helpersColor, helpersColor, helpersColor);
        this.scene.add(this.axes);
        this.xArrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 50, 0xFF7700);
        this.yArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 50, 0x77FF00);
        this.zArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 50, 0x0077FF);
        this.overlayscene.add(this.xArrow);
        this.overlayscene.add(this.yArrow);
        this.overlayscene.add(this.zArrow);
        this.xLabel = this.drawText("X");
        this.xLabel.position.set(55, 0, 0);
        this.overlayscene.add(this.xLabel);
        this.yLabel = this.drawText("Y");
        this.yLabel.position.set(0, 55, 0);
        this.overlayscene.add(this.yLabel);
        this.zLabel = this.drawText("Z");
        this.zLabel.position.set(0, 0, 55);
        return this.overlayscene.add(this.zLabel);
      };

      GlThreeView.prototype.removeAxes = function() {
        this.scene.remove(this.axes);
        this.overlayscene.remove(this.xArrow);
        this.overlayscene.remove(this.yArrow);
        this.overlayscene.remove(this.zArrow);
        this.overlayscene.remove(this.xLabel);
        this.overlayscene.remove(this.yLabel);
        return this.overlayscene.remove(this.zLabel);
      };

      GlThreeView.prototype.addCage = function(mesh) {
        var bbox, cage, cageGeo, delta, height, heightArrow, heightLabel, helpersColor, length, lengthArrow, lengthLabel, lineMat, middlePoint, v, width, widthArrow, widthLabel;
        helpersColor = this.settings.get("helpersColor");
        helpersColor = new THREE.Color().setHex(helpersColor);
        bbox = mesh.geometry.boundingBox;
        length = bbox.max.x - bbox.min.x;
        width = bbox.max.y - bbox.min.y;
        height = bbox.max.z - bbox.min.z;
        cageGeo = new THREE.CubeGeometry(length, width, height);
        v = function(x, y, z) {
          return new THREE.Vector3(x, y, z);
        };
        /*lineMat = new THREE.LineBasicMaterial
          color: helpersColor
          lineWidth: 2
        */

        lineMat = new THREE.MeshBasicMaterial({
          color: helpersColor,
          wireframe: true,
          shading: THREE.FlatShading
        });
        cage = new THREE.Mesh(cageGeo, lineMat);
        middlePoint = function(geometry) {
          var middle;
          middle = new THREE.Vector3();
          middle.x = (geometry.boundingBox.max.x + geometry.boundingBox.min.x) / 2;
          middle.y = (geometry.boundingBox.max.y + geometry.boundingBox.min.y) / 2;
          middle.z = (geometry.boundingBox.max.z + geometry.boundingBox.min.z) / 2;
          return middle;
        };
        delta = middlePoint(mesh.geometry);
        cage.position = delta;
        /*
              texture = @drawText2(height.toFixed(2))
              testLabel = new THREE.Sprite
                map: texture
                useScreenCoordinates: false
                #alignment: THREE.SpriteAlignment.bottom
              testLabel.position.set(-length/2,-width/2,0)
              cage.add testLabel
        */

        widthLabel = this.drawText("w: " + (width.toFixed(2)));
        widthLabel.position.set(-length / 2 - 10, 0, height / 2);
        lengthLabel = this.drawText("l: " + (length.toFixed(2)));
        lengthLabel.position.set(0, -width / 2 - 10, height / 2);
        heightLabel = this.drawText("h: " + (height.toFixed(2)));
        heightLabel.position.set(-length / 2 - 10, -width / 2 - 10, height / 2);
        cage.add(widthLabel);
        cage.add(lengthLabel);
        cage.add(heightLabel);
        widthArrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 50, 0xFF7700);
        lengthArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 50, 0x77FF00);
        heightArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(-length / 2, -width / 2, -height / 2), height, 0x0077FF);
        cage.add(widthArrow);
        cage.add(lengthArrow);
        cage.add(heightArrow);
        return mesh.cageView = cage;
      };

      GlThreeView.prototype.drawText = function(text) {
        var canvas, context, helpersColor, sprite, texture;
        helpersColor = this.settings.get("helpersColor");
        if (helpersColor.indexOf("0x" === 0)) {
          helpersColor = "#" + helpersColor.slice(2);
        }
        canvas = document.createElement('canvas');
        canvas.width = 640;
        canvas.height = 640;
        context = canvas.getContext('2d');
        context.font = "17px sans-serif";
        context.fillStyle = helpersColor;
        context.fillText(text, canvas.width / 2, canvas.height / 2);
        context.strokeStyle = '#FFFFFF';
        context.strokeText(text, canvas.width / 2, canvas.height / 2);
        texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        sprite = new THREE.Sprite({
          map: texture,
          transparent: true,
          useScreenCoordinates: false,
          scaleByViewport: false
        });
        return sprite;
      };

      GlThreeView.prototype.drawText2 = function(text) {
        var canvas, context, helpersColor, texture;
        helpersColor = this.settings.get("helpersColor");
        if (helpersColor.indexOf("0x" === 0)) {
          helpersColor = "#" + helpersColor.slice(2);
        }
        canvas = document.createElement('canvas');
        context = canvas.getContext('2d');
        context.font = "17px sans-serif";
        context.fillStyle = helpersColor;
        context.fillText(text, 0, 17);
        context.strokeStyle = '#FFFFFF';
        context.strokeText(text, 0, 17);
        texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
      };

      GlThreeView.prototype.setupPickerHelper = function() {
        var PI2, canvas, context, texture;
        canvas = document.createElement('canvas');
        canvas.width = 100;
        canvas.height = 100;
        context = canvas.getContext('2d');
        PI2 = Math.PI * 2;
        context.beginPath();
        context.arc(0, 0, 1, 0, PI2, true);
        context.closePath();
        context.fill();
        context.fillText("X", 40, 40);
        texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        this.particleTexture = new THREE.Texture(canvas);
        this.particleTexture.needsUpdate = true;
        return this.particleMaterial = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          color: 0x000000
        });
      };

      GlThreeView.prototype.onResize = function() {
        this.width = $("#glArea").width();
        this.height = window.innerHeight - 10;
        this.camera.setSize(this.width, this.height);
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.width, this.height);
        return this._render();
      };

      GlThreeView.prototype.onRender = function() {
        var container, container2, selectors;
        selectors = this.ui.overlayDiv.children(" .uicons");
        selectors.tooltip();
        if (this.settings.get("showStats")) {
          this.ui.overlayDiv.append(this.stats.domElement);
        }
        this.width = $("#gl").width();
        this.height = window.innerHeight - 10;
        this.camera.setSize(this.width, this.height);
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.width, this.height);
        this._render();
        this.$el.resize(this.onResize);
        window.addEventListener('resize', this.onResize, false);
        container = $(this.ui.renderBlock);
        container.append(this.renderer.domElement);
        this.controls = new THREE.CustomOrbitControls(this.camera, this.el);
        this.controls.rotateSpeed = 1.8;
        this.controls.zoomSpeed = 4.2;
        this.controls.panSpeed = 1.8;
        /*TrackballControls
        @controls.autoRotate = false
        
        
        @controls.noZoom = false
        @controls.noPan = false
        
        @controls.staticMoving = true
        @controls.dynamicDampingFactor = 0.3
        */

        this.controls.addEventListener('change', this._render);
        container2 = $(this.ui.glOverlayBlock);
        container2.append(this.overlayRenderer.domElement);
        this.overlayControls = new THREE.CustomOrbitControls(this.overlayCamera, this.el);
        this.overlayControls.noPan = true;
        this.overlayControls.rotateSpeed = 1.8;
        this.overlayControls.zoomSpeed = 0;
        this.overlayControls.panSpeed = 0;
        this.overlayControls.userZoomSpeed = 0;
        /* 
        @overlayControls.autoRotate = false
        @overlayControls.staticMoving = true
        @overlayControls.dynamicDampingFactor = 0.3
        */

        return this.animate();
      };

      GlThreeView.prototype._render = function() {
        this.renderer.render(this.scene, this.camera);
        this.overlayRenderer.render(this.overlayscene, this.overlayCamera);
        if (this.settings.get("showStats")) {
          return this.stats.update();
        }
      };

      GlThreeView.prototype.animate = function() {
        this.controls.update();
        this.overlayControls.update();
        return requestAnimationFrame(this.animate);
      };

      GlThreeView.prototype.toCsgTest = function(mesh) {
        var csgResult;
        csgResult = THREE.CSG.toCSG(mesh);
        if (csgResult != null) {
          return console.log("CSG conversion result ok:");
        }
      };

      GlThreeView.prototype.fromCsg = function(csg) {
        var app, geom, mat, resultCSG, shine, spec;
        try {
          app = require('app');
          resultCSG = app.csgProcessor.processScript(this.model.get("content"));
          this.model.csg = resultCSG;
          geom = THREE.CSG.fromCSG(resultCSG);
          shine = 1500;
          spec = 10000000000;
          mat = new THREE.MeshPhongMaterial({
            color: 0xFFFFFF,
            shading: THREE.SmoothShading,
            shininess: shine,
            specular: spec,
            metal: true,
            vertexColors: THREE.VertexColors
          });
          if (this.mesh != null) {
            this.scene.remove(this.mesh);
            try {
              this.scene.remove(this.current.cageView);
              this.current = null;
            } catch (_error) {}
          }
          this.mesh = new THREE.Mesh(geom, mat);
          this.mesh.castShadow = this.settings.get("shadows");
          this.mesh.receiveShadow = this.settings.get("selfShadows") && this.settings.get("shadows");
          this.mesh.material.wireframe = this.settings.get("wireframe");
          this.mesh.name = "CSG_OBJ";
          this.scene.add(this.mesh);
          return this.controller.objects = [this.mesh];
        } catch (error) {
          this.scene.remove(this.mesh);
          this.model.csg = null;
          console.log("Csg Generation error: " + error + " ");
          return this.app.vent.trigger("csgParseError", error);
        } finally {
          this.app.vent.trigger("parseCsgDone", this);
          this._render();
        }
      };

      GlThreeView.prototype.addObjs = function() {
        var radius, rings, segments, sphere, sphereMaterial;
        this.cube = new THREE.Mesh(new THREE.CubeGeometry(50, 50, 50), new THREE.MeshBasicMaterial({
          color: 0x000000
        }));
        this.scene.add(this.cube);
        sphereMaterial = new THREE.MeshLambertMaterial({
          color: 0xCC0000
        });
        radius = 50;
        segments = 16;
        rings = 16;
        sphere = new THREE.Mesh(new THREE.SphereGeometry(radius, segments, rings), sphereMaterial);
        sphere.name = "Shinyyy";
        return this.scene.add(sphere);
      };

      return GlThreeView;

    })(marionette.ItemView);
    return GlThreeView;
  });

}).call(this);
