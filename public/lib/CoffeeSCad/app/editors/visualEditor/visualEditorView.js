// Generated by CoffeeScript 1.6.2
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(function(require) {
  var $, CustomOrbitControls, OrbitControls, THREE, TrackballControls, VisualEditorView, combo_cam, contextMenuTemplate, detector, dndMixin, helpers, includeMixin, marionette, reqRes, requestAnimationFrame, stats, threedView_template, utils, vent;

  $ = require('jquery');
  marionette = require('marionette');
  require('bootstrap');
  THREE = require('three');
  combo_cam = require('combo_cam');
  detector = require('detector');
  stats = require('stats');
  utils = require('utils');
  OrbitControls = require('./orbitControls');
  CustomOrbitControls = require('./customOrbitControls');
  TrackballControls = require('./trackballControls');
  reqRes = require('core/messaging/appReqRes');
  vent = require('core/messaging/appVent');
  threedView_template = require("text!./visualEditorView.tmpl");
  requestAnimationFrame = require('core/utils/anim');
  THREE.CSG = require('core/projects/csg/csg.Three');
  helpers = require('./helpers');
  contextMenuTemplate = require("text!./contextMenu.tmpl");
  includeMixin = require('core/utils/mixins/mixins');
  dndMixin = require('core/utils/mixins/dragAndDropRecieverMixin');
  VisualEditorView = (function(_super) {
    __extends(VisualEditorView, _super);

    VisualEditorView.prototype.el = $("#visual");

    VisualEditorView.include(dndMixin);

    VisualEditorView.prototype.template = threedView_template;

    VisualEditorView.prototype.ui = {
      renderBlock: "#glArea",
      glOverlayBlock: "#glOverlay",
      overlayDiv: "#overlay",
      dropOverlay: "#dropOverlay"
    };

    VisualEditorView.prototype.events = {
      'contextmenu': 'rightclick',
      'dragover': 'onDragOver',
      'dragenter': 'onDragEnter',
      'dragexit': 'onDragExit',
      'drop': 'onDrop',
      "resize:stop": "onResizeStop",
      "resize": "onResizeStop",
      "dummy": "onDummy"
    };

    VisualEditorView.prototype.onDummy = function(e) {
      return console.log("dummy event fired");
    };

    VisualEditorView.prototype.onDragOver = function(e) {
      var dm;

      e.preventDefault();
      e.stopPropagation();
      dm = this.ui.dropOverlay[0];
      dm.style.left = (e.clientX + e.offsetX) + 'px';
      dm.style.top = (e.clientY + e.offsetY) + 'px';
      dm.style.left = e.originalEvent.clientX + 'px';
      return dm.style.top = e.originalEvent.clientY + 'px';
    };

    VisualEditorView.prototype.onDragEnter = function(e) {
      return this.ui.dropOverlay.removeClass("hide");
    };

    VisualEditorView.prototype.onDragExit = function(e) {
      return this.ui.dropOverlay.addClass("hide");
    };

    VisualEditorView.prototype.onDrop = function(e) {
      var file, files, _fn, _i, _len,
        _this = this;

      if (e.stopPropagation) {
        e.stopPropagation();
      }
      e.preventDefault();
      this.ui.dropOverlay.addClass("hide");
      files = e.originalEvent.dataTransfer.files;
      _fn = function(file) {
        var ext, name, reader;

        name = file.name;
        ext = name.split(".").pop();
        if (ext === "coffee") {
          reader = new FileReader();
          reader.onload = function(e) {
            var fileContent;

            fileContent = e.target.result;
            return console.log("fileContent", fileContent);
          };
          return reader.readAsText(file);
        }
      };
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        console.log("dropped file", file);
        _fn(file);
      }
      return false;
    };

    function VisualEditorView(options, settings) {
      this.informationOverlay = __bind(this.informationOverlay, this);
      this._updateAssemblyVisualAttrs = __bind(this._updateAssemblyVisualAttrs, this);
      this._importGeom = __bind(this._importGeom, this);
      this.fromCsg = __bind(this.fromCsg, this);
      this.animate = __bind(this.animate, this);
      this._render = __bind(this._render, this);
      this.onDomRefresh = __bind(this.onDomRefresh, this);
      this.onResizeStop = __bind(this.onResizeStop, this);
      this.onResize = __bind(this.onResize, this);
      this._computeViewSize = __bind(this._computeViewSize, this);
      this.addCage = __bind(this.addCage, this);
      this.removeGrid = __bind(this.removeGrid, this);
      this.addGrid = __bind(this.addGrid, this);
      this.setBgColor = __bind(this.setBgColor, this);
      this.setupView = __bind(this.setupView, this);
      this.setupLights = __bind(this.setupLights, this);
      this.configure = __bind(this.configure, this);
      this.init = __bind(this.init, this);
      this.settingsChanged = __bind(this.settingsChanged, this);
      this.projectCompileFailed = __bind(this.projectCompileFailed, this);
      this.projectCompiled = __bind(this.projectCompiled, this);
      this.selectObj = __bind(this.selectObj, this);
      this.rightclick = __bind(this.rightclick, this);
      this.makeScreeshot = __bind(this.makeScreeshot, this);
      this._setupEventBindings = __bind(this._setupEventBindings, this);
      this.onDragExit = __bind(this.onDragExit, this);
      this.onDragOver = __bind(this.onDragOver, this);
      this.onDummy = __bind(this.onDummy, this);
      var _this = this;

      VisualEditorView.__super__.constructor.call(this, options);
      this.vent = vent;
      this.settings = options.settings;
      this.stats = new stats();
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.top = '30px';
      this.stats.domElement.style.zIndex = 100;
      this.settings.on("change", this.settingsChanged);
      this._setupEventBindings();
      reqRes.addHandler("project:getScreenshot", function() {
        return _this.makeScreeshot();
      });
      this.defaultCameraPosition = new THREE.Vector3(100, 100, 200);
      this.width = 100;
      this.height = 100;
      this.init();
    }

    VisualEditorView.prototype._setupEventBindings = function() {
      this.model.on("compiled", this.projectCompiled);
      return this.model.on("compile:error", this.projectCompileFailed);
    };

    VisualEditorView.prototype.makeScreeshot = function(width, height) {
      var canvas, ctx, d, img, imgAsDataURL, srcImg,
        _this = this;

      if (width == null) {
        width = 300;
      }
      if (height == null) {
        height = 300;
      }
      srcImg = this.renderer.domElement.toDataURL("image/png");
      canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      ctx = canvas.getContext('2d');
      d = $.Deferred();
      imgAsDataURL = null;
      img = new Image();
      img.onload = function() {
        ctx.drawImage(img, 0, 0, width, height);
        imgAsDataURL = canvas.toDataURL("image/png");
        return d.resolve(imgAsDataURL);
      };
      img.src = srcImg;
      return d;
    };

    VisualEditorView.prototype.rightclick = function(ev) {
      "used either for selection or context menu";
      var x, y;

      normalizeEvent(ev);
      x = ev.offsetX;
      y = ev.offsetY;
      this.selectObj(x, y);
      /*
      {ContextMenuRegion,ContextMenu} = require "views/contextMenuView"
      @contextMenu = new ContextMenu()
      @contextMenuRegion.show @contextMenu
      */

      ev.preventDefault();
      return false;
    };

    VisualEditorView.prototype.selectObj = function(mouseX, mouseY) {
      var intersects, newMat, raycaster, unselect, v,
        _this = this;

      v = new THREE.Vector3((mouseX / this.width) * 2 - 1, -(mouseY / this.height) * 2 + 1, 0.5);
      this.projector.unprojectVector(v, this.camera);
      raycaster = new THREE.Raycaster(this.camera.position, v.sub(this.camera.position).normalize());
      intersects = raycaster.intersectObjects(this.scene.children, true);
      unselect = function() {
        if (_this.current != null) {
          _this.current.selected = false;
          _this.current.material = _this.current.origMaterial;
          if (_this.current.cage != null) {
            _this.current.remove(_this.current.cage);
            _this.current.cage = null;
          }
          return _this.current = null;
        }
      };
      if (this.current != null) {
        unselect();
      }
      if (intersects != null) {
        if (intersects.length > 0) {
          if (intersects[0].object.name !== "workplane") {
            this.current = intersects[0].object;
            newMat = new THREE.MeshLambertMaterial({
              color: 0xCC0000
            });
            this.current.origMaterial = this.current.material;
            this.current.material = newMat;
            this.addCage(this.current);
            this.camera.lookAt(this.current.position.clone());
            this.controls.zoomInOn(this.current);
            this._render();
          }
        }
      }
      return this._render();
    };

    VisualEditorView.prototype.switchModel = function(newModel) {
      this.model.off("compiled", this.projectCompiled);
      this.model.off("compile:error", this.projectCompileFailed);
      try {
        this.scene.remove(this.current.cageView);
      } catch (_error) {}
      if (this.assembly != null) {
        this.scene.remove(this.assembly);
        this.current = null;
      }
      this.model = newModel;
      this._setupEventBindings();
      return this._render();
    };

    VisualEditorView.prototype.projectCompiled = function(res) {
      return this.fromCsg(res);
    };

    VisualEditorView.prototype.projectCompileFailed = function() {
      if (this.assembly != null) {
        this.scene.remove(this.assembly);
        this.assembly = null;
      }
      return this._render();
    };

    VisualEditorView.prototype.settingsChanged = function(settings, value) {
      var error, key, offset, tgt, val, _ref;

      _ref = this.settings.changedAttributes();
      for (key in _ref) {
        val = _ref[key];
        switch (key) {
          case "bgColor":
            this.setBgColor();
            break;
          case "bgColor2":
            this.setBgColor();
            break;
          case "renderer":
            delete this.renderer;
            this.init();
            this.fromCsg(this.model);
            this.render();
            break;
          case "showGrid":
            if (val) {
              this.addGrid();
            } else {
              this.removeGrid();
            }
            break;
          case "gridSize":
            if (this.grid != null) {
              this.removeGrid();
              this.addGrid();
            }
            break;
          case "gridStep":
            if (this.grid != null) {
              this.removeGrid();
              this.addGrid();
            }
            break;
          case "gridColor":
            if (this.grid != null) {
              this.grid.setColor(val);
            }
            break;
          case "gridOpacity":
            if (this.grid != null) {
              this.grid.setOpacity(val);
            }
            break;
          case "gridText":
            this.grid.toggleText(val);
            break;
          case "gridNumberingPosition":
            this.grid.setTextLocation(val);
            break;
          case "showAxes":
            if (val) {
              this.addAxes();
            } else {
              this.removeAxes();
            }
            break;
          case "axesSize":
            this.removeAxes();
            this.addAxes();
            break;
          case "shadows":
            if (!val) {
              this.renderer.clearTarget(this.light.shadowMap);
              this._updateAssemblyVisualAttrs();
              this._render();
              this.renderer.shadowMapAutoUpdate = false;
              if (this.settings.showGrid) {
                this.removeGrid();
                this.addGrid();
              }
            } else {
              this.renderer.shadowMapAutoUpdate = true;
              this._updateAssemblyVisualAttrs();
              this._render();
              if (this.settings.showGrid) {
                this.removeGrid();
                this.addGrid();
              }
            }
            break;
          case "selfShadows":
            this._updateAssemblyVisualAttrs();
            this._render();
            break;
          case "showStats":
            if (val) {
              this.ui.overlayDiv.append(this.stats.domElement);
            } else {
              $(this.stats.domElement).remove();
            }
            break;
          case "projection":
            if (val === "orthographic") {
              this.camera.toOrthographic();
            } else {
              this.camera.toPerspective();
              this.camera.setZoom(1);
            }
            break;
          case "position":
            this.setupView(val);
            break;
          case "objectViewMode":
            this._updateAssemblyVisualAttrs();
            this._render();
            break;
          case 'center':
            try {
              tgt = this.controls.target;
              offset = new THREE.Vector3().sub(this.controls.target.clone());
              this.controls.target.addSelf(offset);
              this.camera.position.addSelf(offset);
            } catch (_error) {
              error = _error;
              console.log("error " + error + " in center");
            }
            this.camera.lookAt(this.scene.position);
            break;
          case 'helpersColor':
            if (this.axes != null) {
              this.removeAxes();
              this.addAxes();
            }
            break;
          case 'textColor':
            if (this.axes != null) {
              this.removeAxes();
              this.addAxes();
            }
            break;
          case 'showConnectors':
            if (val) {
              this.assembly.traverse(function(object) {
                console.log("pouet");
                console.log(object);
                if (object.name === "connectors") {
                  return object.visible = true;
                }
              });
            } else {
              this.assembly.traverse(function(object) {
                console.log("pouet");
                console.log(object);
                if (object.name === "connectors") {
                  return object.visible = false;
                }
              });
            }
        }
      }
      return this._render();
    };

    VisualEditorView.prototype.init = function() {
      var val;

      this.renderer = null;
      this.configure(this.settings);
      this.renderer.shadowMapEnabled = true;
      this.renderer.shadowMapAutoUpdate = true;
      this.projector = new THREE.Projector();
      this.setupScene();
      this.setupOverlayScene();
      this.setBgColor();
      if (this.settings.shadows) {
        this.renderer.shadowMapAutoUpdate = this.settings.shadows;
      }
      if (this.settings.showGrid) {
        this.addGrid();
      }
      if (this.settings.showAxes) {
        this.addAxes();
      }
      if (this.settings.projection === "orthographic") {
        this.camera.toOrthographic();
        this.camera.setZoom(6);
      } else {

      }
      if (this.mesh != null) {
        this.mesh.material.wireframe = this.settings.wireframe;
      }
      val = this.settings.position;
      return this.setupView(val);
    };

    VisualEditorView.prototype.configure = function(settings) {
      var renderer;

      if (settings.renderer) {
        renderer = settings.renderer;
        if (renderer === "webgl") {
          if (detector.webgl) {
            console.log("Gl Renderer");
            this.renderer = new THREE.WebGLRenderer({
              clearColor: 0x00000000,
              clearAlpha: 0,
              antialias: true,
              preserveDrawingBuffer: true
            });
            this.renderer.clear();
            this.renderer.setSize(this.width, this.height);
            this.overlayRenderer = new THREE.WebGLRenderer({
              clearColor: 0x000000,
              clearAlpha: 0,
              antialias: true
            });
            return this.overlayRenderer.setSize(350, 250);
          } else if (!detector.webgl && !detector.canvas) {
            return console.log("No Webgl and no canvas (fallback) support, cannot render");
          } else if (!detector.webgl && detector.canvas) {
            this.renderer = new THREE.CanvasRenderer({
              clearColor: 0x00000000,
              clearAlpha: 0,
              antialias: true
            });
            this.renderer.clear();
            this.overlayRenderer = new THREE.CanvasRenderer({
              clearColor: 0x000000,
              clearAlpha: 0,
              antialias: true
            });
            this.overlayRenderer.setSize(350, 250);
            return this.renderer.setSize(this.width, this.height);
          } else {
            return console.log("No Webgl and no canvas (fallback) support, cannot render");
          }
        } else if (renderer === "canvas") {
          if (detector.canvas) {
            this.renderer = new THREE.CanvasRenderer({
              clearColor: 0x00000000,
              clearAlpha: 0,
              antialias: true
            });
            this.renderer.clear();
            this.overlayRenderer = new THREE.CanvasRenderer({
              clearColor: 0x000000,
              clearAlpha: 0,
              antialias: true
            });
            this.overlayRenderer.setSize(350, 250);
            return this.renderer.setSize(this.width, this.height);
          } else if (!detector.canvas) {
            return console.log("No canvas support, cannot render");
          }
        }
      }
    };

    VisualEditorView.prototype.setupScene = function() {
      var ASPECT, FAR, NEAR;

      this.viewAngle = 45;
      ASPECT = this.width / this.height;
      NEAR = 1;
      FAR = 10000;
      this.camera = new THREE.CombinedCamera(this.width, this.height, this.viewAngle, NEAR, FAR, NEAR, FAR);
      this.camera.up = new THREE.Vector3(0, 0, 1);
      this.camera.position = this.defaultCameraPosition;
      this.scene = new THREE.Scene();
      this.scene.add(this.camera);
      this.setupLights();
      return this.cameraHelper = new THREE.CameraHelper(this.camera);
    };

    VisualEditorView.prototype.setupOverlayScene = function() {
      var ASPECT, FAR, NEAR;

      ASPECT = 350 / 250;
      NEAR = 1;
      FAR = 10000;
      this.overlayCamera = new THREE.CombinedCamera(350, 250, this.viewAngle, NEAR, FAR, NEAR, FAR);
      this.overlayCamera.up = new THREE.Vector3(0, 0, 1);
      this.overlayScene = new THREE.Scene();
      return this.overlayScene.add(this.overlayCamera);
    };

    VisualEditorView.prototype.setupLights = function() {
      var ambientLight, pointLight, pointLight2, spotLight;

      pointLight = new THREE.PointLight(0x333333, 4);
      pointLight.position.x = -2500;
      pointLight.position.y = -2500;
      pointLight.position.z = 2200;
      pointLight2 = new THREE.PointLight(0x333333, 3);
      pointLight2.position.x = 2500;
      pointLight2.position.y = 2500;
      pointLight2.position.z = -5200;
      this.ambientColor = 0x253565;
      this.ambientColor = 0x354575;
      this.ambientColor = 0x455585;
      this.ambientColor = 0x565595;
      ambientLight = new THREE.AmbientLight(this.ambientColor);
      spotLight = new THREE.SpotLight(0xbbbbbb, 1.5);
      spotLight.position.x = 0;
      spotLight.position.y = 0;
      spotLight.position.z = 300;
      spotLight.castShadow = true;
      this.light = spotLight;
      this.scene.add(ambientLight);
      this.scene.add(pointLight);
      this.scene.add(pointLight2);
      this.scene.add(spotLight);
      return this.camera.add(pointLight);
    };

    VisualEditorView.prototype.setupView = function(val) {
      var error, nPost, offset, resetCam,
        _this = this;

      resetCam = function() {
        _this.camera.position.z = 0;
        _this.camera.position.y = 0;
        return _this.camera.position.x = 0;
      };
      switch (val) {
        case 'diagonal':
          this.camera.position = this.defaultCameraPosition;
          this.overlayCamera.position.x = 150;
          this.overlayCamera.position.y = 150;
          this.overlayCamera.position.z = 250;
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
          break;
        case 'top':
          this.camera.toTopView();
          this.overlayCamera.toTopView();
          console.log(this.camera);
          /*
          try
            offset = @camera.position.clone().sub(@controls.target)
            nPost = new THREE.Vector3()
            nPost.z = offset.length()
            @camera.position = nPost
            
          catch error
            @camera.position = new THREE.Vector3(0,0,@defaultCameraPosition.z)
            
          @overlayCamera.position = new THREE.Vector3(0,0,250)
          @camera.lookAt(@scene.position)
          @overlayCamera.lookAt(@overlayScene.position)
          */

          break;
        case 'bottom':
          try {
            offset = this.camera.position.clone().sub(this.controls.target);
            nPost = new THREE.Vector3();
            nPost.z = -offset.length();
            this.camera.position = nPost;
          } catch (_error) {
            error = _error;
            this.camera.position = new THREE.Vector3(0, 0, -this.defaultCameraPosition.z);
          }
          this.overlayCamera.position = new THREE.Vector3(0, 0, -250);
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
          break;
        case 'front':
          try {
            offset = this.camera.position.clone().sub(this.controls.target);
            nPost = new THREE.Vector3();
            nPost.y = -offset.length();
            this.camera.position = nPost;
          } catch (_error) {
            error = _error;
            this.camera.position = new THREE.Vector3(0, -this.defaultCameraPosition.y, 0);
          }
          this.overlayCamera.position = new THREE.Vector3(0, -250, 0);
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
          break;
        case 'back':
          try {
            offset = this.camera.position.clone().sub(this.controls.target);
            nPost = new THREE.Vector3();
            nPost.y = offset.length();
            this.camera.position = nPost;
          } catch (_error) {
            error = _error;
            this.camera.position = new THREE.Vector3(0, this.defaultCameraPosition.y, 0);
          }
          this.overlayCamera.position = new THREE.Vector3(0, 250, 0);
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
          break;
        case 'left':
          try {
            offset = this.camera.position.clone().sub(this.controls.target);
            nPost = new THREE.Vector3();
            nPost.x = offset.length();
            this.camera.position = nPost;
          } catch (_error) {
            error = _error;
            this.camera.position = new THREE.Vector3(this.defaultCameraPosition.x, 0, 0);
          }
          this.overlayCamera.position = new THREE.Vector3(250, 0, 0);
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
          break;
        case 'right':
          try {
            offset = this.camera.position.clone().sub(this.controls.target);
            nPost = new THREE.Vector3();
            nPost.x = -offset.length();
            this.camera.position = nPost;
          } catch (_error) {
            error = _error;
            this.camera.position = new THREE.Vector3(-this.defaultCameraPosition.x, 0, 0);
          }
          this.overlayCamera.position = new THREE.Vector3(-250, 0, 0);
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
      }
      return this._render();
    };

    VisualEditorView.prototype.setBgColor = function() {
      var bgColor1, bgColor2;

      console.log("setting bg color");
      bgColor1 = this.settings.bgColor;
      bgColor2 = this.settings.bgColor2;
      $("body").css("background-color", bgColor1);
      if (bgColor1 !== bgColor2) {
        $("body").css("background-image", "-moz-radial-gradient(center center, circle cover, " + bgColor1 + "," + bgColor2 + "  100%)");
        $("body").css("background-image", "-webkit-radial-gradient(center center, circle cover, " + bgColor1 + "," + bgColor2 + "  100%)");
        $("body").css("background-image", "-o-radial-gradient(center center, circle cover, " + bgColor1 + "," + bgColor2 + "  100%)");
        $("body").css("background-image", "-ms-radial-gradient(center center, circle cover, " + bgColor1 + "," + bgColor2 + "  100%)");
        $("body").css("background-image", "radial-gradient(center center, circle cover, " + bgColor1 + "," + bgColor2 + "  100%)");
        $("body").css("background-repeat", "no-repeat");
        return $("body").css("background-attachment", "fixed");
      } else {
        $("body").css("background-image", "");
        $("body").css("background-image", "");
        $("body").css("background-repeat", "");
        return $("body").css("background-attachment", "");
      }
    };

    VisualEditorView.prototype.addGrid = function() {
      /*
      Adds both grid & plane (for shadow casting), based on the parameters from the settings object
      */

      var gridColor, gridOpacity, gridSize, gridStep, gridText;

      if (!this.grid) {
        gridSize = this.settings.gridSize;
        gridStep = this.settings.gridStep;
        gridColor = this.settings.gridColor;
        gridOpacity = this.settings.gridOpacity;
        gridText = this.settings.gridText;
        this.grid = new helpers.Grid({
          size: gridSize,
          step: gridStep,
          color: gridColor,
          opacity: gridOpacity,
          addText: gridText,
          textColor: this.settings.textColor
        });
        return this.scene.add(this.grid);
      }
    };

    VisualEditorView.prototype.removeGrid = function() {
      if (this.grid) {
        this.scene.remove(this.grid);
        return delete this.grid;
      }
    };

    VisualEditorView.prototype.addAxes = function() {
      var helpersColor;

      helpersColor = this.settings.helpersColor;
      this.axes = new helpers.LabeledAxes({
        xColor: helpersColor,
        yColor: helpersColor,
        zColor: helpersColor,
        size: this.settings.gridSize / 2,
        addLabels: false,
        addArrows: false
      });
      this.scene.add(this.axes);
      this.overlayAxes = new helpers.LabeledAxes({
        textColor: this.settings.textColor,
        size: this.settings.axesSize
      });
      return this.overlayScene.add(this.overlayAxes);
    };

    VisualEditorView.prototype.removeAxes = function() {
      this.scene.remove(this.axes);
      this.overlayScene.remove(this.overlayAxes);
      delete this.axes;
      return delete this.overlayAxes;
    };

    VisualEditorView.prototype.addCage = function(mesh) {
      return new helpers.BoundingCage({
        mesh: mesh,
        color: this.settings.helpersColor,
        textColor: this.settings.textColor
      });
    };

    VisualEditorView.prototype.setupPickerHelper = function() {
      var PI2, canvas, context, texture;

      canvas = document.createElement('canvas');
      canvas.width = 100;
      canvas.height = 100;
      context = canvas.getContext('2d');
      PI2 = Math.PI * 2;
      context.beginPath();
      context.arc(0, 0, 1, 0, PI2, true);
      context.closePath();
      context.fill();
      context.fillText("X", 40, 40);
      texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      this.particleTexture = new THREE.Texture(canvas);
      this.particleTexture.needsUpdate = true;
      return this.particleMaterial = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        color: 0x000000
      });
    };

    VisualEditorView.prototype._computeViewSize = function() {
      var eastWidth, westWidth;

      this.height = window.innerHeight - 10;
      this.height = this.$el.height();
      if (this.initialized == null) {
        this.initialized = true;
        console.log("initial view size setting");
        westWidth = $("#_dockZoneWest").width();
        eastWidth = $("#_dockZoneEast").width();
        this.width = window.innerWidth - (westWidth + eastWidth);
      } else {
        westWidth = $("#_dockZoneWest").width();
        eastWidth = $("#_dockZoneEast").width();
        this.width = window.innerWidth - (westWidth + eastWidth);
      }
      return this.height = window.innerHeight - 30;
    };

    VisualEditorView.prototype.onResize = function() {
      this._computeViewSize();
      this.camera.aspect = this.width / this.height;
      this.camera.setSize(this.width, this.height);
      this.renderer.setSize(this.width, this.height);
      this.camera.updateProjectionMatrix();
      return this._render();
    };

    VisualEditorView.prototype.onResizeStop = function() {
      return this.onResize();
    };

    VisualEditorView.prototype.onDomRefresh = function() {
      var container, container2;

      if (this.settings.showStats) {
        this.ui.overlayDiv.append(this.stats.domElement);
      }
      this._computeViewSize();
      this.camera.aspect = this.width / this.height;
      this.camera.setSize(this.width, this.height);
      this.renderer.setSize(this.width, this.height);
      this.camera.updateProjectionMatrix();
      this._render();
      this.$el.resize(this.onResize);
      window.addEventListener('resize', this.onResize, false);
      container = $(this.ui.renderBlock);
      container.append(this.renderer.domElement);
      this.renderer.domElement.setAttribute("id", "3dView");
      console.log(this.renderer.domElement.id);
      this.controls = new CustomOrbitControls(this.camera, this.el);
      this.controls.rotateSpeed = 1.8;
      this.controls.zoomSpeed = 4.2;
      this.controls.panSpeed = 0.8;
      this.controls.addEventListener('change', this._render);
      this.controls.staticMoving = true;
      this.controls.dynamicDampingFactor = 0.3;
      container2 = $(this.ui.glOverlayBlock);
      container2.append(this.overlayRenderer.domElement);
      this.overlayControls = new CustomOrbitControls(this.overlayCamera, this.el);
      this.overlayControls.noPan = true;
      this.overlayControls.rotateSpeed = 1.8;
      this.overlayControls.zoomSpeed = 0;
      this.overlayControls.panSpeed = 0;
      this.overlayControls.userZoomSpeed = 0;
      return this.animate();
    };

    VisualEditorView.prototype._render = function() {
      this.renderer.render(this.scene, this.camera);
      this.overlayRenderer.render(this.overlayScene, this.overlayCamera);
      if (this.settings.showStats) {
        return this.stats.update();
      }
    };

    VisualEditorView.prototype.animate = function() {
      this.controls.update();
      this.overlayControls.update();
      return requestAnimationFrame(this.animate);
    };

    VisualEditorView.prototype.toCsgTest = function(mesh) {
      var csgResult;

      csgResult = THREE.CSG.toCSG(mesh);
      if (csgResult != null) {
        return console.log("CSG conversion result ok:");
      }
    };

    VisualEditorView.prototype.fromCsg = function() {
      var end, index, part, start, _ref;

      start = new Date().getTime();
      if (this.assembly != null) {
        this.scene.remove(this.assembly);
        this.current = null;
      }
      this.assembly = new THREE.Mesh(new THREE.Geometry());
      this.assembly.name = "assembly";
      if (this.model.rootAssembly.children != null) {
        _ref = this.model.rootAssembly.children;
        for (index in _ref) {
          part = _ref[index];
          this._importGeom(part, this.assembly);
        }
      }
      this.scene.add(this.assembly);
      end = new Date().getTime();
      console.log("Csg visualization time: " + (end - start));
      this._updateAssemblyVisualAttrs();
      return this._render();
    };

    VisualEditorView.prototype._importGeom = function(csgObj, rootObj) {
      var child, conn, connectorMesh, geom, i, index, mat, mesh, opacity, shine, spec, _ref, _ref1, _results;

      geom = THREE.CSG.fromCSG(csgObj);
      shine = 1500;
      spec = 1000;
      opacity = geom.opacity;
      if (this.renderer instanceof THREE.CanvasRenderer) {
        mat = new THREE.MeshLambertMaterial({
          color: 0xFFFFFF
        });
        mat.overdraw = true;
      } else {
        mat = new THREE.MeshPhongMaterial({
          color: 0xFFFFFF,
          shading: THREE.SmoothShading,
          shininess: shine,
          specular: spec,
          metal: false,
          vertexColors: THREE.VertexColors
        });
        mat.opacity = opacity;
        mat.ambient = mat.color;
        mat.transparent = opacity < 1;
      }
      mesh = new THREE.Mesh(geom, mat);
      mesh.position = geom.tmpPos;
      delete geom.tmpPos;
      mesh.castShadow = this.settings.shadows;
      mesh.receiveShadow = this.settings.selfShadows && this.settings.shadows;
      mesh.material.wireframe = this.settings.wireframe;
      mesh.name = csgObj.constructor.name;
      if (this.renderer instanceof THREE.CanvasRenderer) {
        mesh.doubleSided = true;
      }
      _ref = geom.connectors;
      for (i in _ref) {
        conn = _ref[i];
        /*
        mat =  new THREE.LineBasicMaterial({color: 0xff0000})
        line = new THREE.Line(conn, mat)
        @mesh.add line
        */

        mat = new THREE.MeshLambertMaterial({
          color: 0xff0000
        });
        connectorMesh = new THREE.Mesh(conn, mat);
        connectorMesh.name = "connectors";
        connectorMesh.position = conn.basePoint;
        if (this.settings.get('showConnectors') === false) {
          connectorMesh.visible = false;
        }
        mesh.add(connectorMesh);
      }
      rootObj.add(mesh);
      if (csgObj.children != null) {
        _ref1 = csgObj.children;
        _results = [];
        for (index in _ref1) {
          child = _ref1[index];
          _results.push(this._importGeom(child, mesh));
        }
        return _results;
      }
    };

    VisualEditorView.prototype._updateAssemblyVisualAttrs = function() {
      var applyStyle, child, removeRenderHelpers, _i, _len, _ref, _results,
        _this = this;

      console.log("applying object visual style");
      removeRenderHelpers = function(child) {
        if (child.renderSubElementsHelper != null) {
          child.remove(child.renderSubElementsHelper);
          return child.renderSubElementsHelper = null;
        }
      };
      applyStyle = function(child) {
        var basicMaterial1, dashMaterial, geom, obj2, obj3, obj4, renderSubElementsHelper, subchild, wireFrameMaterial, _i, _len, _ref, _results;

        child.castShadow = _this.settings.shadows;
        child.receiveShadow = _this.settings.selfShadows && _this.settings.shadows;
        switch (_this.settings.objectViewMode) {
          case "shaded":
            removeRenderHelpers(child);
            if (child.material != null) {
              child.material.wireframe = false;
            }
            break;
          case "wireframe":
            removeRenderHelpers(child);
            if (child.material != null) {
              child.material.wireframe = true;
            }
            break;
          case "structural":
            if (child.material != null) {
              child.material.wireframe = false;
            }
            if (child.geometry != null) {
              removeRenderHelpers(child);
              basicMaterial1 = new THREE.MeshBasicMaterial({
                color: 0xccccdd,
                side: THREE.DoubleSide,
                depthTest: true,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
              });
              dashMaterial = new THREE.LineDashedMaterial({
                color: 0x000000,
                dashSize: 2,
                gapSize: 3,
                depthTest: false,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
              });
              wireFrameMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                depthTest: true,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1,
                wireframe: true
              });
              renderSubElementsHelper = new THREE.Object3D();
              renderSubElementsHelper.name = "renderSubs";
              geom = child.geometry;
              obj2 = new THREE.Mesh(geom.clone(), basicMaterial1);
              obj3 = new THREE.Line(_this.geo2line(geom.clone()), dashMaterial, THREE.LinePieces);
              obj4 = new THREE.Mesh(geom.clone(), wireFrameMaterial);
              renderSubElementsHelper.add(obj2);
              renderSubElementsHelper.add(obj3);
              renderSubElementsHelper.add(obj4);
              child.add(renderSubElementsHelper);
              child.renderSubElementsHelper = renderSubElementsHelper;
            }
        }
        _ref = child.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          subchild = _ref[_i];
          if (subchild.name !== "renderSubs" && subchild.name !== "connectors") {
            _results.push(applyStyle(subchild));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      if (this.assembly != null) {
        _ref = this.assembly.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          _results.push(applyStyle(child));
        }
        return _results;
      }
    };

    VisualEditorView.prototype.geo2line = function(geo) {
      var a, b, c, d, face, geometry, i, vertices, _i, _ref;

      geometry = new THREE.Geometry();
      vertices = geometry.vertices;
      for (i = _i = 0, _ref = geo.faces.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        face = geo.faces[i];
        if (face instanceof THREE.Face3) {
          a = geo.vertices[face.a].clone();
          b = geo.vertices[face.b].clone();
          c = geo.vertices[face.c].clone();
          vertices.push(a, b, b, c, c, a);
        } else if (face instanceof THREE.Face4) {
          a = geo.vertices[face.a].clone();
          b = geo.vertices[face.b].clone();
          c = geo.vertices[face.c].clone();
          d = geo.vertices[face.d].clone();
          vertices.push(a, b, b, c, c, d, d, a);
        }
      }
      geometry.computeLineDistances();
      return geometry;
    };

    VisualEditorView.prototype._addIndicator = function(mesh) {
      var geometry, line, material;

      material = new THREE.LineDashedMaterial({
        color: 0xffaa00,
        dashSize: 3,
        gapSize: 1,
        linewidth: 2
      });
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(mesh.position.x, mesh.position.y, mesh.position.z));
      geometry.vertices.push(new THREE.Vector3(150, 0, 150));
      geometry.vertices.push(new THREE.Vector3(150, 0, 157));
      geometry.vertices.push(new THREE.Vector3(150, 0, 160));
      line = new THREE.Line(geometry, material, THREE.LineStrip);
      return mesh.add(line);
    };

    VisualEditorView.prototype._addIndicator2 = function(mesh) {
      var cube, geometryCube, geometrySpline, hilbert3D, i, index, material, points, position, recursion, spline, subdivisions, _i, _ref;

      hilbert3D = function(center, side, iterations, v0, v1, v2, v3, v4, v5, v6, v7) {
        var half, tmp, vec, vec_s;

        half = side / 2;
        vec_s = [new THREE.Vector3(center.x - half, center.y + half, center.z - half), new THREE.Vector3(center.x - half, center.y + half, center.z + half), new THREE.Vector3(center.x - half, center.y - half, center.z + half), new THREE.Vector3(center.x - half, center.y - half, center.z - half), new THREE.Vector3(center.x + half, center.y - half, center.z - half), new THREE.Vector3(center.x + half, center.y - half, center.z + half), new THREE.Vector3(center.x + half, center.y + half, center.z + half), new THREE.Vector3(center.x + half, center.y + half, center.z - half)];
        vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]];
        if (--iterations >= 0) {
          tmp = [];
          Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));
          Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));
          Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));
          Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));
          Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));
          Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));
          Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));
          Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7));
          return tmp;
        }
        return vec;
      };
      cube = function(size) {
        var geometry, h;

        h = size * 0.5;
        geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(-h, -h, -h));
        geometry.vertices.push(new THREE.Vector3(-h, h, -h));
        geometry.vertices.push(new THREE.Vector3(-h, h, -h));
        geometry.vertices.push(new THREE.Vector3(h, h, -h));
        geometry.vertices.push(new THREE.Vector3(h, h, -h));
        geometry.vertices.push(new THREE.Vector3(h, -h, -h));
        geometry.vertices.push(new THREE.Vector3(h, -h, -h));
        geometry.vertices.push(new THREE.Vector3(-h, -h, -h));
        geometry.vertices.push(new THREE.Vector3(-h, -h, h));
        geometry.vertices.push(new THREE.Vector3(-h, h, h));
        geometry.vertices.push(new THREE.Vector3(-h, h, h));
        geometry.vertices.push(new THREE.Vector3(h, h, h));
        geometry.vertices.push(new THREE.Vector3(h, h, h));
        geometry.vertices.push(new THREE.Vector3(h, -h, h));
        geometry.vertices.push(new THREE.Vector3(h, -h, h));
        geometry.vertices.push(new THREE.Vector3(-h, -h, h));
        geometry.vertices.push(new THREE.Vector3(-h, -h, -h));
        geometry.vertices.push(new THREE.Vector3(-h, -h, h));
        geometry.vertices.push(new THREE.Vector3(-h, h, -h));
        geometry.vertices.push(new THREE.Vector3(-h, h, h));
        geometry.vertices.push(new THREE.Vector3(h, h, -h));
        geometry.vertices.push(new THREE.Vector3(h, h, h));
        geometry.vertices.push(new THREE.Vector3(h, -h, -h));
        geometry.vertices.push(new THREE.Vector3(h, -h, h));
        return geometry;
      };
      subdivisions = 6;
      recursion = 1;
      points = hilbert3D(new THREE.Vector3(0, 0, 0), 25.0, recursion, 0, 1, 2, 3, 4, 5, 6, 7);
      spline = new THREE.Spline(points);
      geometrySpline = new THREE.Geometry();
      for (i = _i = 0, _ref = points.length * subdivisions; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        index = i / (points.length * subdivisions);
        position = spline.getPoint(index);
        geometrySpline.vertices[i] = new THREE.Vector3(position.x, position.y, position.z);
      }
      geometryCube = cube(350);
      geometryCube.computeLineDistances();
      geometrySpline.computeLineDistances();
      material = new THREE.LineDashedMaterial({
        color: 0xffaa00,
        dashSize: 3,
        gapSize: 1,
        linewidth: 2
      });
      cube = new THREE.Line(geometryCube, material, THREE.LinePieces);
      spline = new THREE.Line(geometrySpline, material, THREE.LinePieces);
      mesh.add(cube);
      return mesh.add(spline);
    };

    VisualEditorView.prototype.informationOverlay = function(object3d) {
      var left, p, percX, percY, top, v;

      p = object3d.matrixWorld.getPosition().clone();
      v = projector.projectVector(p, this.camera);
      percX = (v.x + 1) / 2;
      percY = (-v.y + 1) / 2;
      left = percX * this.width;
      top = percY * this.height;
      return $trackingOverlay.css('left', (left - $trackingOverlay.width() / 2) + 'px').css('top', (top - $trackingOverlay.height() / 2) + 'px');
    };

    return VisualEditorView;

  })(Backbone.Marionette.ItemView);
  return VisualEditorView;
});
