// Generated by CoffeeScript 1.6.2
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(function(require) {
  var $, CustomOrbitControls, ObjectExport, ObjectParser, OrbitControls, Shaders, THREE, VisualEditorView, combo_cam, detector, dndMixin, helpers, includeMixin, marionette, reqRes, requestAnimationFrame, stats, threedView_template, transformControls, utils, vent;

  $ = require('jquery');
  marionette = require('marionette');
  require('bootstrap');
  THREE = require('three');
  combo_cam = require('combo_cam');
  detector = require('detector');
  stats = require('stats');
  utils = require('utils');
  OrbitControls = require('./orbitControls');
  CustomOrbitControls = require('./customOrbitControls');
  transformControls = require('transformControls');
  ObjectExport = require('ObjectExport');
  ObjectParser = require('ObjectParser');
  Shaders = require('./shaders');
  reqRes = require('core/messaging/appReqRes');
  vent = require('core/messaging/appVent');
  threedView_template = require("text!./visualEditorView.tmpl");
  requestAnimationFrame = require('core/utils/anim');
  THREE.CSG = require('core/projects/csg/csg.Three');
  helpers = require('./helpers');
  includeMixin = require('core/utils/mixins/mixins');
  dndMixin = require('core/utils/mixins/dragAndDropRecieverMixin');
  VisualEditorView = (function(_super) {
    __extends(VisualEditorView, _super);

    VisualEditorView.prototype.el = $("#visual");

    VisualEditorView.include(dndMixin);

    VisualEditorView.prototype.template = threedView_template;

    VisualEditorView.prototype.ui = {
      renderBlock: "#glArea",
      glOverlayBlock: "#glOverlay",
      overlayDiv: "#overlay"
    };

    VisualEditorView.prototype.events = {
      "mousedown": "_onSelectAttempt",
      "contextmenu": "_onRightclick",
      "mousemove": "_onMouseMove",
      "resize:stop": "onResizeStop",
      "resize": "onResizeStop"
    };

    function VisualEditorView(options, settings) {
      this._updateAssemblyVisualAttrs = __bind(this._updateAssemblyVisualAttrs, this);
      this._importGeom = __bind(this._importGeom, this);
      this.fromCsg = __bind(this.fromCsg, this);
      this.animate = __bind(this.animate, this);
      this._render = __bind(this._render, this);
      this.onDomRefresh = __bind(this.onDomRefresh, this);
      this.onResizeStop = __bind(this.onResizeStop, this);
      this.onResize = __bind(this.onResize, this);
      this._computeViewSize = __bind(this._computeViewSize, this);
      this.removeGrid = __bind(this.removeGrid, this);
      this.addGrid = __bind(this.addGrid, this);
      this.setBgColor = __bind(this.setBgColor, this);
      this.settingsChanged = __bind(this.settingsChanged, this);
      this._onProjectCompileFailed = __bind(this._onProjectCompileFailed, this);
      this._onProjectCompiled = __bind(this._onProjectCompiled, this);
      this._onRightclick = __bind(this._onRightclick, this);
      this._onSelectAttempt = __bind(this._onSelectAttempt, this);
      this.makeScreenshot = __bind(this.makeScreenshot, this);
      this._setupEventBindings = __bind(this._setupEventBindings, this);
      this.setupView = __bind(this.setupView, this);
      this.setupPostProcess = __bind(this.setupPostProcess, this);
      this.setupLights = __bind(this.setupLights, this);
      this.setupRenderers = __bind(this.setupRenderers, this);
      this.reloadAssembly = __bind(this.reloadAssembly, this);
      this.init = __bind(this.init, this);
      this.settingsChanged = __bind(this.settingsChanged, this);
      this.init = __bind(this.init, this);
      var _this = this;

      VisualEditorView.__super__.constructor.call(this, options);
      this.vent = vent;
      this.settings = options.settings;
      this.settings.on("change", this.settingsChanged);
      this._setupEventBindings();
      reqRes.addHandler("project:getScreenshot", function() {
        return _this.makeScreenshot();
      });
      this.stats = new stats();
      this.renderer = null;
      this.overlayRenderer = null;
      this.defaultCameraPosition = new THREE.Vector3(100, 100, 200);
      this.width = 100;
      this.height = 100;
      this.dpr = 1;
      this.init();
      this.selectionHelper = new helpers.SelectionHelper({
        renderCallback: this._render,
        camera: this.camera,
        color: 0x000000,
        textColor: this.settings.textColor
      });
    }

    VisualEditorView.prototype.init = function() {
      var BlendShader, DotScreenPass, EdgeShader, EdgeShader2, EffectComposer, FXAAShader, VignetteShader;

      EffectComposer = require('EffectComposer');
      DotScreenPass = require('DotScreenPass');
      FXAAShader = require('FXAAShader');
      EdgeShader2 = require('EdgeShader2');
      EdgeShader = require('EdgeShader');
      VignetteShader = require('VignetteShader');
      BlendShader = require('BlendShader');
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.top = '30px';
      return this.stats.domElement.style.zIndex = 100;
    };

    VisualEditorView.prototype.settingsChanged = function(settings, value) {
      var error, key, offset, shadowResolution, tgt, val, _ref;

      _ref = this.settings.changedAttributes();
      for (key in _ref) {
        val = _ref[key];
        switch (key) {
          case "bgColor":
            this.setBgColor();
            break;
          case "bgColor2":
            this.setBgColor();
            break;
          case "renderer":
            delete this.renderer;
            this.init();
            this.fromCsg(this.model);
            this.render();
            break;
          case "showGrid":
            if (val) {
              this.addGrid();
            } else {
              this.removeGrid();
            }
            break;
          case "gridSize":
            if (this.grid != null) {
              this.removeGrid();
              this.addGrid();
            }
            break;
          case "gridStep":
            if (this.grid != null) {
              this.removeGrid();
              this.addGrid();
            }
            break;
          case "gridColor":
            if (this.grid != null) {
              this.grid.setColor(val);
            }
            break;
          case "gridOpacity":
            if (this.grid != null) {
              this.grid.setOpacity(val);
            }
            break;
          case "gridText":
            this.grid.toggleText(val);
            break;
          case "gridNumberingPosition":
            this.grid.setTextLocation(val);
            break;
          case "showAxes":
            if (val) {
              this.addAxes();
            } else {
              this.removeAxes();
            }
            break;
          case "axesSize":
            this.removeAxes();
            this.addAxes();
            break;
          case "shadows":
            if (!val) {
              this.renderer.clearTarget(this.light.shadowMap);
              this._updateAssemblyVisualAttrs();
              this._render();
              this.renderer.shadowMapAutoUpdate = false;
              if (this.settings.showGrid) {
                this.removeGrid();
                this.addGrid();
              }
            } else {
              this.renderer.shadowMapAutoUpdate = true;
              this._updateAssemblyVisualAttrs();
              this._render();
              if (this.settings.showGrid) {
                this.removeGrid();
                this.addGrid();
              }
            }
            break;
          case "shadowResolution":
            shadowResolution = parseInt(val.split("x")[0]);
            this.light.shadowMapWidth = shadowResolution;
            this.light.shadowMapHeight = shadowResolution;
            if (this.settings.shadows) {
              this.renderer.shadowMapAutoUpdate = true;
              this._updateAssemblyVisualAttrs();
              this._render();
              if (this.settings.showGrid) {
                this.removeGrid();
                this.addGrid();
              }
            }
            break;
          case "selfShadows":
            this._updateAssemblyVisualAttrs();
            this._render();
            break;
          case "showStats":
            if (val) {
              this.ui.overlayDiv.append(this.stats.domElement);
            } else {
              $(this.stats.domElement).remove();
            }
            break;
          case "projection":
            if (val === "orthographic") {
              this.camera.toOrthographic();
            } else {
              this.camera.toPerspective();
              this.camera.setZoom(1);
            }
            break;
          case "position":
            this.setupView(val);
            break;
          case "objectViewMode":
            this._updateAssemblyVisualAttrs();
            this._render();
            break;
          case 'center':
            try {
              tgt = this.controls.target;
              offset = new THREE.Vector3().sub(this.controls.target.clone());
              this.controls.target.addSelf(offset);
              this.camera.position.addSelf(offset);
            } catch (_error) {
              error = _error;
              console.log("error " + error + " in center");
            }
            this.camera.lookAt(this.scene.position);
            break;
          case 'helpersColor':
            if (this.axes != null) {
              this.removeAxes();
              this.addAxes();
            }
            break;
          case 'textColor':
            if (this.axes != null) {
              this.removeAxes();
              this.addAxes();
            }
            break;
          case 'showConnectors':
            if (val) {
              this.assembly.traverse(function(object) {
                console.log("pouet");
                console.log(object);
                if (object.name === "connectors") {
                  return object.visible = true;
                }
              });
            } else {
              this.assembly.traverse(function(object) {
                console.log("pouet");
                console.log(object);
                if (object.name === "connectors") {
                  return object.visible = false;
                }
              });
            }
        }
      }
      return this._render();
    };

    VisualEditorView.prototype.init = function() {
      this.setupRenderers(this.settings);
      this.setupScenes();
      this.setupPostProcess();
      if (this.settings.shadows) {
        this.renderer.shadowMapAutoUpdate = this.settings.shadows;
      }
      if (this.settings.showGrid) {
        this.addGrid();
      }
      if (this.settings.showAxes) {
        this.addAxes();
      }
      this.setBgColor();
      return this.setupView(this.settings.position);
    };

    VisualEditorView.prototype.reloadAssembly = function() {
      var loader, reloadedAssembly;

      reloadedAssembly = this.model.rootFolder.get(".assembly");
      console.log("reloadedAssembly", reloadedAssembly);
      if (reloadedAssembly != null) {
        reloadedAssembly = JSON.parse(reloadedAssembly.content);
        loader = new THREE.ObjectParser();
        this.assembly = loader.parse(reloadedAssembly);
        console.log("parse Result", this.assembly);
        this.scene.add(this.assembly);
        this._updateAssemblyVisualAttrs();
        return this._render();
      }
    };

    VisualEditorView.prototype.setupRenderers = function(settings) {
      var getValidRenderer, renderer;

      getValidRenderer = function(settings) {
        var renderer;

        renderer = settings.renderer;
        if (!detector.webgl && !detector.canvas) {
          throw new Error("No Webgl and no canvas (fallback) support, cannot render");
        }
        if (renderer === "webgl") {
          if (detector.webgl) {
            return renderer;
          } else if (!detector.webgl && detector.canvas) {
            return "canvas";
          }
        }
        if (renderer === "canvas") {
          if (detector.canvas) {
            return renderer;
          }
        }
      };
      renderer = getValidRenderer(settings);
      console.log("" + renderer + " renderer");
      if (renderer === "webgl") {
        this.renderer = new THREE.WebGLRenderer({
          antialias: true,
          preserveDrawingBuffer: true
        });
        this.renderer.setSize(this.width, this.height);
        this.renderer.clear();
        this.renderer.setClearColor(0x00000000, 0);
        this.renderer.shadowMapEnabled = true;
        this.renderer.shadowMapAutoUpdate = true;
        this.renderer.shadowMapSoft = true;
        this.overlayRenderer = new THREE.WebGLRenderer({
          antialias: true
        });
        this.overlayRenderer.setSize(350, 250);
        return this.overlayRenderer.setClearColor(0x00000000, 0);
      } else if (renderer === "canvas") {
        this.renderer = new THREE.CanvasRenderer({
          antialias: true
        });
        this.renderer.setSize(this.width, this.height);
        this.renderer.clear();
        this.overlayRenderer = new THREE.CanvasRenderer({
          clearColor: 0x000000,
          clearAlpha: 0,
          antialias: true
        });
        this.overlayRenderer.setSize(350, 250);
        return this.overlayRenderer.setClearColor(0x00000000, 0);
      }
    };

    VisualEditorView.prototype.setupScenes = function() {
      this.setupScene();
      return this.setupOverlayScene();
    };

    VisualEditorView.prototype.setupScene = function() {
      var ASPECT;

      this.viewAngle = 45;
      ASPECT = this.width / this.height;
      this.NEAR = 1;
      this.FAR = 1000;
      this.camera = new THREE.CombinedCamera(this.width, this.height, this.viewAngle, this.NEAR, this.FAR, this.NEAR, this.FAR);
      this.camera.up = new THREE.Vector3(0, 0, 1);
      this.camera.position = this.defaultCameraPosition;
      this.scene = new THREE.Scene();
      this.scene.add(this.camera);
      this.setupLights();
      return this.cameraHelper = new THREE.CameraHelper(this.camera);
    };

    VisualEditorView.prototype.setupOverlayScene = function() {
      var ASPECT, FAR, NEAR;

      ASPECT = 350 / 250;
      NEAR = 1;
      FAR = 10000;
      this.overlayCamera = new THREE.CombinedCamera(350, 250, this.viewAngle, NEAR, FAR, NEAR, FAR);
      this.overlayCamera.up = new THREE.Vector3(0, 0, 1);
      this.overlayScene = new THREE.Scene();
      return this.overlayScene.add(this.overlayCamera);
    };

    VisualEditorView.prototype.setupLights = function() {
      var ambientLight, pointLight, pointLight2, shadowResolution, spotLight;

      pointLight = new THREE.PointLight(0x333333, 4);
      pointLight.position.x = -2500;
      pointLight.position.y = -2500;
      pointLight.position.z = 2200;
      pointLight2 = new THREE.PointLight(0x333333, 3);
      pointLight2.position.x = 2500;
      pointLight2.position.y = 2500;
      pointLight2.position.z = -5200;
      this.ambientColor = 0x253565;
      this.ambientColor = 0x354575;
      this.ambientColor = 0x455585;
      this.ambientColor = 0x565595;
      ambientLight = new THREE.AmbientLight(this.ambientColor);
      spotLight = new THREE.SpotLight(0xbbbbbb, 1.5);
      spotLight.position.x = 50;
      spotLight.position.y = 50;
      spotLight.position.z = 300;
      spotLight.shadowCameraNear = 1;
      spotLight.shadowCameraFar = 500;
      spotLight.shadowCameraFov = 50;
      spotLight.shadowMapBias = 0.000039;
      spotLight.shadowMapDarkness = 0.5;
      shadowResolution = parseInt(this.settings.shadowResolution.split("x")[0]);
      spotLight.shadowMapWidth = shadowResolution;
      spotLight.shadowMapHeight = shadowResolution;
      spotLight.castShadow = true;
      this.light = spotLight;
      this.scene.add(ambientLight);
      this.scene.add(pointLight);
      this.scene.add(pointLight2);
      this.scene.add(spotLight);
      return this.camera.add(pointLight);
    };

    VisualEditorView.prototype.setupPostProcess = function() {
      var copyPass, depthPass, depthShader, depthUniforms, dotScreenPass, edgeDetectPass, edgeDetectPass2, overlayRenderPass, renderPass, vignettePass;

      if (window.devicePixelRatio === !void 0) {
        this.dpr = window.devicePixelRatio;
      }
      depthShader = THREE.ShaderLib["depthRGBA"];
      depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
      this.depthMaterial = new THREE.ShaderMaterial({
        fragmentShader: depthShader.fragmentShader,
        vertexShader: depthShader.vertexShader,
        uniforms: depthUniforms
      });
      this.depthMaterial.blending = THREE.NoBlending;
      this.depthTarget = new THREE.WebGLRenderTarget(this.width, this.height, {
        minFilter: THREE.NearestFilter,
        magFilter: THREE.NearestFilter,
        format: THREE.RGBAFormat
      });
      renderPass = new THREE.RenderPass(this.scene, this.camera);
      overlayRenderPass = new THREE.RenderPass(this.overlayScene, this.overlayCamera);
      this.depthTarget = new THREE.WebGLRenderTarget(this.width, this.height, {
        minFilter: THREE.NearestFilter,
        magFilter: THREE.NearestFilter,
        format: THREE.RGBFormat
      });
      this.depthMaterial = new THREE.MeshDepthMaterial();
      depthPass = new THREE.RenderPass(this.scene, this.camera, this.depthMaterial);
      copyPass = new THREE.ShaderPass(THREE.CopyShader);
      dotScreenPass = new THREE.ShaderPass(THREE.DotScreenShader);
      this.fxAAPass = new THREE.ShaderPass(THREE.FXAAShader);
      this.fxAAPass.uniforms['resolution'].value.set(1 / (this.width * this.dpr), 1 / (this.height * this.dpr));
      edgeDetectPass = new THREE.ShaderPass(THREE.EdgeShader);
      edgeDetectPass2 = new THREE.ShaderPass(THREE.EdgeShader2);
      vignettePass = new THREE.ShaderPass(THREE.VignetteShader);
      this.depthExtractPass = new THREE.ShaderPass(Shaders.depthExtractShader);
      this.composer = new THREE.EffectComposer(this.renderer);
      this.composer.setSize(this.width * this.dpr, this.height * this.dpr);
      this.composer.addPass(renderPass);
      this.composer.addPass(this.fxAAPass);
      return this.composer.passes[this.composer.passes.length - 1].renderToScreen = true;
    };

    VisualEditorView.prototype.setupView = function(val) {
      var error, nPost, offset, resetCam,
        _this = this;

      if (this.settings.projection === "orthographic") {
        this.camera.toOrthographic();
        this.camera.setZoom(6);
      }
      resetCam = function() {
        _this.camera.position.z = 0;
        _this.camera.position.y = 0;
        return _this.camera.position.x = 0;
      };
      switch (val) {
        case 'diagonal':
          this.camera.position = this.defaultCameraPosition;
          this.overlayCamera.position.x = 150;
          this.overlayCamera.position.y = 150;
          this.overlayCamera.position.z = 250;
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
          break;
        case 'top':
          this.camera.toTopView();
          this.overlayCamera.toTopView();
          console.log(this.camera);
          /*
          try
            offset = @camera.position.clone().sub(@controls.target)
            nPost = new THREE.Vector3()
            nPost.z = offset.length()
            @camera.position = nPost
            
          catch error
            @camera.position = new THREE.Vector3(0,0,@defaultCameraPosition.z)
            
          @overlayCamera.position = new THREE.Vector3(0,0,250)
          @camera.lookAt(@scene.position)
          @overlayCamera.lookAt(@overlayScene.position)
          */

          break;
        case 'bottom':
          try {
            offset = this.camera.position.clone().sub(this.controls.target);
            nPost = new THREE.Vector3();
            nPost.z = -offset.length();
            this.camera.position = nPost;
          } catch (_error) {
            error = _error;
            this.camera.position = new THREE.Vector3(0, 0, -this.defaultCameraPosition.z);
          }
          this.overlayCamera.position = new THREE.Vector3(0, 0, -250);
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
          break;
        case 'front':
          try {
            offset = this.camera.position.clone().sub(this.controls.target);
            nPost = new THREE.Vector3();
            nPost.y = -offset.length();
            this.camera.position = nPost;
          } catch (_error) {
            error = _error;
            this.camera.position = new THREE.Vector3(0, -this.defaultCameraPosition.y, 0);
          }
          this.overlayCamera.position = new THREE.Vector3(0, -250, 0);
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
          break;
        case 'back':
          try {
            offset = this.camera.position.clone().sub(this.controls.target);
            nPost = new THREE.Vector3();
            nPost.y = offset.length();
            this.camera.position = nPost;
          } catch (_error) {
            error = _error;
            this.camera.position = new THREE.Vector3(0, this.defaultCameraPosition.y, 0);
          }
          this.overlayCamera.position = new THREE.Vector3(0, 250, 0);
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
          break;
        case 'left':
          try {
            offset = this.camera.position.clone().sub(this.controls.target);
            nPost = new THREE.Vector3();
            nPost.x = offset.length();
            this.camera.position = nPost;
          } catch (_error) {
            error = _error;
            this.camera.position = new THREE.Vector3(this.defaultCameraPosition.x, 0, 0);
          }
          this.overlayCamera.position = new THREE.Vector3(250, 0, 0);
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
          break;
        case 'right':
          try {
            offset = this.camera.position.clone().sub(this.controls.target);
            nPost = new THREE.Vector3();
            nPost.x = -offset.length();
            this.camera.position = nPost;
          } catch (_error) {
            error = _error;
            this.camera.position = new THREE.Vector3(-this.defaultCameraPosition.x, 0, 0);
          }
          this.overlayCamera.position = new THREE.Vector3(-250, 0, 0);
          this.camera.lookAt(this.scene.position);
          this.overlayCamera.lookAt(this.overlayScene.position);
      }
      return this._render();
    };

    VisualEditorView.prototype._setupEventBindings = function() {
      this.model.on("compiled", this._onProjectCompiled);
      return this.model.on("compile:error", this._onProjectCompileFailed);
    };

    VisualEditorView.prototype.makeScreenshot = function(width, height) {
      if (width == null) {
        width = 300;
      }
      if (height == null) {
        height = 300;
      }
      return helpers.captureScreen(this.renderer.domElement, width, height);
    };

    VisualEditorView.prototype._onSelectAttempt = function(ev) {
      "used either for selection or context menu";
      var hiearchyRoot, selected, x, y;

      normalizeEvent(ev);
      x = ev.offsetX;
      y = ev.offsetY;
      hiearchyRoot = this.assembly != null ? this.assembly.children : this.scene.children;
      this.selectionHelper.hiearchyRoot = hiearchyRoot;
      this.selectionHelper.viewWidth = this.width;
      this.selectionHelper.viewHeight = this.height;
      selected = this.selectionHelper.selectObjectAt(x, y);
      /*
      selectionChange = false
      if selected?
        if @currentSelection?
          if @currentSelection != selected
            selectionChange = true
        else 
          selectionChange = true
           
      if selectionChange
        if @currentSelection?
          controls = @currentSelection.controls
          if controls?
            controls.detatch(@currentSelection)
            controls.removeEventListener( 'change', @_render)
            @scene.remove(controls.gizmo)
            controls = null
            @currentSelection = null
        
        @currentSelection = selected        
        controls = new THREE.TransformControls(@camera, @renderer.domElement)
        console.log controls
        controls.addEventListener( 'change', @_render );
        controls.attatch( selected );
        controls.scale = 0.65;
        @scene.add( controls.gizmo );
        selected.controls = controls
      
      @_render()
      */

      ev.preventDefault();
      return false;
    };

    VisualEditorView.prototype._onRightclick = function(ev) {
      return this.selectionHelper._unSelect();
    };

    VisualEditorView.prototype._onMouseMove = function(ev) {
      var hiearchyRoot, x, y;

      normalizeEvent(ev);
      x = ev.offsetX;
      y = ev.offsetY;
      hiearchyRoot = this.assembly != null ? this.assembly.children : this.scene.children;
      this.selectionHelper.hiearchyRoot = hiearchyRoot;
      this.selectionHelper.viewWidth = this.width;
      this.selectionHelper.viewHeight = this.height;
      return this.selectionHelper.highlightObjectAt(x, y);
    };

    VisualEditorView.prototype.switchModel = function(newModel) {
      this.model.off("compiled", this._onProjectCompiled);
      this.model.off("compile:error", this._onProjectCompileFailed);
      try {
        this.scene.remove(this.current.cageView);
      } catch (_error) {}
      if (this.assembly != null) {
        this.scene.remove(this.assembly);
        this.current = null;
      }
      this.model = newModel;
      this.selectionHelper._unSelect();
      this._setupEventBindings();
      this._render();
      return this.reloadAssembly();
    };

    VisualEditorView.prototype._onProjectCompiled = function(res) {
      this.selectionHelper._unSelect();
      return this.fromCsg(res);
    };

    VisualEditorView.prototype._onProjectCompileFailed = function() {
      if (this.assembly != null) {
        this.scene.remove(this.assembly);
        this.assembly = null;
      }
      return this._render();
    };

    VisualEditorView.prototype.settingsChanged = function(settings, value) {
      var error, key, offset, tgt, val, _ref;

      _ref = this.settings.changedAttributes();
      for (key in _ref) {
        val = _ref[key];
        switch (key) {
          case "bgColor":
            this.setBgColor();
            break;
          case "renderer":
            delete this.renderer;
            this.init();
            this.fromCsg(this.model);
            this.render();
            break;
          case "showGrid":
            if (val) {
              this.addGrid();
            } else {
              this.removeGrid();
            }
            break;
          case "gridSize":
            if (this.grid != null) {
              this.removeGrid();
              this.addGrid();
            }
            break;
          case "gridStep":
            if (this.grid != null) {
              this.removeGrid();
              this.addGrid();
            }
            break;
          case "gridColor":
            if (this.grid != null) {
              this.grid.setColor(val);
            }
            break;
          case "gridOpacity":
            if (this.grid != null) {
              this.grid.setOpacity(val);
            }
            break;
          case "gridText":
            this.grid.toggleText(val);
            break;
          case "gridNumberingPosition":
            this.grid.setTextLocation(val);
            break;
          case "showAxes":
            if (val) {
              this.addAxes();
            } else {
              this.removeAxes();
            }
            break;
          case "axesSize":
            this.removeAxes();
            this.addAxes();
            break;
          case "shadows":
            if (!val) {
              this.renderer.clearTarget(this.light.shadowMap);
              this._updateAssemblyVisualAttrs();
              this._render();
              this.renderer.shadowMapAutoUpdate = false;
              if (this.settings.showGrid) {
                this.removeGrid();
                this.addGrid();
              }
            } else {
              this.renderer.shadowMapAutoUpdate = true;
              this._updateAssemblyVisualAttrs();
              this._render();
              if (this.settings.showGrid) {
                this.removeGrid();
                this.addGrid();
              }
            }
            break;
          case "selfShadows":
            this._updateAssemblyVisualAttrs();
            this._render();
            break;
          case "showStats":
            if (val) {
              this.ui.overlayDiv.append(this.stats.domElement);
            } else {
              $(this.stats.domElement).remove();
            }
            break;
          case "projection":
            if (val === "orthographic") {
              this.camera.toOrthographic();
            } else {
              this.camera.toPerspective();
              this.camera.setZoom(1);
            }
            break;
          case "position":
            this.setupView(val);
            break;
          case "objectViewMode":
            this._updateAssemblyVisualAttrs();
            this._render();
            break;
          case 'center':
            try {
              tgt = this.controls.target;
              offset = new THREE.Vector3().sub(this.controls.target.clone());
              this.controls.target.addSelf(offset);
              this.camera.position.addSelf(offset);
            } catch (_error) {
              error = _error;
              console.log("error " + error + " in center");
            }
            this.camera.lookAt(this.scene.position);
            break;
          case 'helpersColor':
            if (this.axes != null) {
              this.removeAxes();
              this.addAxes();
            }
            break;
          case 'textColor':
            if (this.axes != null) {
              this.removeAxes();
              this.addAxes();
            }
            break;
          case 'showConnectors':
            if (val) {
              this.assembly.traverse(function(object) {
                if (object.name === "connectors") {
                  return object.visible = true;
                }
              });
            } else {
              this.assembly.traverse(function(object) {
                console.log("pouet");
                console.log(object);
                if (object.name === "connectors") {
                  return object.visible = false;
                }
              });
            }
        }
      }
      return this._render();
    };

    VisualEditorView.prototype.setBgColor = function() {
      var bgColor, bgColor1, bgColor2;

      bgColor1 = this.settings.bgColor;
      bgColor2 = this.settings.bgColor2;
      $("body").css("background-color", bgColor1);
      console.log(this.settings.bgColor);
      return bgColor = this.settings.bgColor.split('#').pop();
      /*
      bgColor = a.map((x) -> #For each array element
        x = parseInt(x).toString(16) #Convert to a base16 string
        (if (x.length is 1) then "0" + x else x) #Add zero if we get only one character
      )     
      
      b = "0x"+b.join("");
      */

      /*      
      @renderer.clearColor=0x363335
      console.log @renderer
      @renderer.setClearColorHex( 0xFFFFFF, @renderer.getClearAlpha() )
      */

    };

    VisualEditorView.prototype.addGrid = function() {
      /*
      Adds both grid & plane (for shadow casting), based on the parameters from the settings object
      */

      var gridColor, gridOpacity, gridSize, gridStep, gridText;

      if (!this.grid) {
        gridSize = this.settings.gridSize;
        gridStep = this.settings.gridStep;
        gridColor = this.settings.gridColor;
        gridOpacity = this.settings.gridOpacity;
        gridText = this.settings.gridText;
        this.grid = new helpers.Grid({
          size: gridSize,
          step: gridStep,
          color: gridColor,
          opacity: gridOpacity,
          addText: gridText,
          textColor: this.settings.textColor
        });
        return this.scene.add(this.grid);
      }
    };

    VisualEditorView.prototype.removeGrid = function() {
      if (this.grid) {
        this.scene.remove(this.grid);
        return delete this.grid;
      }
    };

    VisualEditorView.prototype.addAxes = function() {
      var helpersColor;

      helpersColor = this.settings.helpersColor;
      this.axes = new helpers.LabeledAxes({
        xColor: helpersColor,
        yColor: helpersColor,
        zColor: helpersColor,
        size: this.settings.gridSize / 2,
        addLabels: false,
        addArrows: false
      });
      this.scene.add(this.axes);
      this.overlayAxes = new helpers.LabeledAxes({
        textColor: this.settings.textColor,
        size: this.settings.axesSize
      });
      return this.overlayScene.add(this.overlayAxes);
    };

    VisualEditorView.prototype.removeAxes = function() {
      this.scene.remove(this.axes);
      this.overlayScene.remove(this.overlayAxes);
      delete this.axes;
      return delete this.overlayAxes;
    };

    VisualEditorView.prototype._computeViewSize = function() {
      var eastWidth, westWidth;

      this.height = window.innerHeight - 10;
      this.height = this.$el.height();
      if (this.initialized == null) {
        this.initialized = true;
        westWidth = $("#_dockZoneWest").width();
        eastWidth = $("#_dockZoneEast").width();
        this.width = window.innerWidth - (westWidth + eastWidth);
      } else {
        westWidth = $("#_dockZoneWest").width();
        eastWidth = $("#_dockZoneEast").width();
        this.width = window.innerWidth - (westWidth + eastWidth);
      }
      return this.height = window.innerHeight - 30;
    };

    VisualEditorView.prototype.onResize = function() {
      this._computeViewSize();
      if (window.devicePixelRatio != null) {
        this.dpr = window.devicePixelRatio;
      }
      this.fxAAPass.uniforms['resolution'].value.set(1 / (this.width * this.dpr), 1 / (this.height * this.dpr));
      this.composer.setSize(this.width * this.dpr, this.height * this.dpr);
      this.depthExtractPass.uniforms['size'].value.set(this.width, this.height);
      this.depthExtractPass.uniforms['cameraNear'].value = 0.1;
      this.depthExtractPass.uniforms['cameraFar'].value = 100;
      this.camera.aspect = this.width / this.height;
      this.camera.setSize(this.width, this.height);
      this.renderer.setSize(this.width, this.height);
      this.camera.updateProjectionMatrix();
      return this._render();
    };

    VisualEditorView.prototype.onResizeStop = function() {
      return this.onResize();
    };

    VisualEditorView.prototype.onDomRefresh = function() {
      var container, container2;

      if (this.settings.showStats) {
        this.ui.overlayDiv.append(this.stats.domElement);
      }
      this._computeViewSize();
      this.camera.aspect = this.width / this.height;
      this.camera.setSize(this.width, this.height);
      this.renderer.setSize(this.width, this.height);
      this.camera.updateProjectionMatrix();
      this._render();
      this.$el.resize(this.onResize);
      window.addEventListener('resize', this.onResize, false);
      container = $(this.ui.renderBlock);
      container.append(this.renderer.domElement);
      this.renderer.domElement.setAttribute("id", "3dView");
      console.log(this.renderer.domElement.id);
      this.controls = new CustomOrbitControls(this.camera, this.el);
      this.controls.rotateSpeed = 1.8;
      this.controls.zoomSpeed = 4.2;
      this.controls.panSpeed = 0.8;
      this.controls.addEventListener('change', this._render);
      this.controls.staticMoving = true;
      this.controls.dynamicDampingFactor = 0.3;
      container2 = $(this.ui.glOverlayBlock);
      container2.append(this.overlayRenderer.domElement);
      this.overlayControls = new CustomOrbitControls(this.overlayCamera, this.el);
      this.overlayControls.noPan = true;
      this.overlayControls.noZoom = true;
      this.overlayControls.rotateSpeed = 1.8;
      this.overlayControls.zoomSpeed = 0;
      this.overlayControls.panSpeed = 0;
      this.overlayControls.userZoomSpeed = 0;
      return this.animate();
    };

    VisualEditorView.prototype._render = function() {
      var centerLeft, centerTop, height, infoText, length, width, _ref;

      if (this.selectionHelper != null) {
        if (this.selectionHelper.currentSelect != null) {
          _ref = this.selectionHelper.get2DBB(this.selectionHelper.currentSelect, this.width, this.height), centerLeft = _ref[0], centerTop = _ref[1], length = _ref[2], width = _ref[3], height = _ref[4];
          $("#testOverlay2").removeClass("hide");
          $("#testOverlay2").css("left", centerLeft + this.$el.offset().left);
          $("#testOverlay2").css('top', (centerTop - $("#testOverlay2").height() / 2) + 'px');
          infoText = "" + this.selectionHelper.currentSelect.name;
          $("#testOverlay2").text(infoText);
        } else {
          $("#testOverlay2").addClass("hide");
        }
      } else {
        $("#testOverlay2").addClass("hide");
      }
      THREE.EffectComposer.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      THREE.EffectComposer.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null);
      THREE.EffectComposer.scene = new THREE.Scene();
      THREE.EffectComposer.scene.add(THREE.EffectComposer.quad);
      /*
      @scene.overrideMaterial = @depthMaterial
      @renderer.render( @scene, @camera, @depthTarget )
      */

      /*
      if @assembly?
        for child in @assembly.children
          child.material = @depthMaterial
      */

      this.renderer.render(this.scene, this.camera);
      if (this.settings.showStats) {
        return this.stats.update();
      }
    };

    VisualEditorView.prototype.animate = function() {
      this.controls.update();
      this.overlayControls.update();
      return requestAnimationFrame(this.animate);
    };

    VisualEditorView.prototype.fromCsg = function() {
      var end, exported, exporter, index, part, start, _ref;

      start = new Date().getTime();
      if (this.assembly != null) {
        this.scene.remove(this.assembly);
        this.current = null;
      }
      this.assembly = new THREE.Object3D();
      this.assembly.name = "assembly";
      if (this.model.rootAssembly.children != null) {
        _ref = this.model.rootAssembly.children;
        for (index in _ref) {
          part = _ref[index];
          this._importGeom(part, this.assembly);
        }
      }
      this.scene.add(this.assembly);
      end = new Date().getTime();
      console.log("Csg visualization time: " + (end - start));
      this._updateAssemblyVisualAttrs();
      exporter = new THREE.ObjectExporter();
      exported = exporter.parse(this.assembly);
      exported = JSON.stringify(exported);
      if (!this.model.rootFolder.get(".assembly")) {
        this.model.addFile({
          name: ".assembly",
          content: exported
        });
      } else {
        this.model.rootFolder.get(".assembly").content = exported;
      }
      return this._render();
    };

    VisualEditorView.prototype._importGeom = function(csgObj, rootObj) {
      var child, conn, connectorMesh, geom, i, index, mat, mesh, opacity, shine, spec, _ref, _ref1, _results;

      geom = THREE.CSG.fromCSG(csgObj);
      shine = 1500;
      spec = 1000;
      opacity = geom.opacity;
      if (this.renderer instanceof THREE.CanvasRenderer) {
        mat = new THREE.MeshLambertMaterial({
          color: 0xFFFFFF
        });
        mat.overdraw = true;
      } else {
        mat = new THREE.MeshPhongMaterial({
          color: 0xFFFFFF,
          shading: THREE.SmoothShading,
          shininess: shine,
          specular: spec,
          metal: false,
          vertexColors: THREE.VertexColors
        });
        mat.opacity = opacity;
        mat.ambient = mat.color;
        mat.transparent = opacity < 1;
      }
      mesh = new THREE.Mesh(geom, mat);
      mesh.position = geom.tmpPos;
      delete geom.tmpPos;
      mesh.castShadow = this.settings.shadows;
      mesh.receiveShadow = this.settings.selfShadows && this.settings.shadows;
      mesh.material.wireframe = this.settings.wireframe;
      mesh.name = csgObj.constructor.name;
      if (this.renderer instanceof THREE.CanvasRenderer) {
        mesh.doubleSided = true;
      }
      _ref = geom.connectors;
      for (i in _ref) {
        conn = _ref[i];
        /*
        mat =  new THREE.LineBasicMaterial({color: 0xff0000})
        line = new THREE.Line(conn, mat)
        @mesh.add line
        */

        mat = new THREE.MeshLambertMaterial({
          color: 0xff0000
        });
        connectorMesh = new THREE.Mesh(conn, mat);
        connectorMesh.name = "connectors";
        connectorMesh.position = conn.basePoint;
        if (this.settings.get('showConnectors') === false) {
          connectorMesh.visible = false;
        }
        mesh.add(connectorMesh);
      }
      rootObj.add(mesh);
      if (csgObj.children != null) {
        _ref1 = csgObj.children;
        _results = [];
        for (index in _ref1) {
          child = _ref1[index];
          _results.push(this._importGeom(child, mesh));
        }
        return _results;
      }
    };

    VisualEditorView.prototype._updateAssemblyVisualAttrs = function() {
      var applyStyle, child, removeRenderHelpers, _i, _len, _ref, _results,
        _this = this;

      console.log("applying object visual style");
      removeRenderHelpers = function(child) {
        if (child.renderSubElementsHelper != null) {
          child.remove(child.renderSubElementsHelper);
          return child.renderSubElementsHelper = null;
        }
      };
      applyStyle = function(child) {
        var basicMaterial1, dashMaterial, geom, obj2, obj3, obj4, renderSubElementsHelper, subchild, wireFrameMaterial, _i, _len, _ref, _results;

        child.castShadow = _this.settings.shadows;
        child.receiveShadow = _this.settings.selfShadows && _this.settings.shadows;
        if (child.material != null) {
          child.material.vertexColors = THREE.VertexColors;
        }
        switch (_this.settings.objectViewMode) {
          case "shaded":
            removeRenderHelpers(child);
            if (child.material != null) {
              child.material.wireframe = false;
            }
            break;
          case "wireframe":
            removeRenderHelpers(child);
            if (child.material != null) {
              child.material.wireframe = true;
            }
            break;
          case "structural":
            if (child.material != null) {
              child.material.wireframe = false;
            }
            if (child.geometry != null) {
              removeRenderHelpers(child);
              basicMaterial1 = new THREE.MeshBasicMaterial({
                color: 0xccccdd,
                side: THREE.DoubleSide,
                depthTest: true,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
              });
              dashMaterial = new THREE.LineDashedMaterial({
                color: 0x000000,
                dashSize: 2,
                gapSize: 3,
                depthTest: false,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
              });
              wireFrameMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                depthTest: true,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1,
                wireframe: true
              });
              renderSubElementsHelper = new THREE.Object3D();
              renderSubElementsHelper.name = "renderSubs";
              geom = child.geometry;
              obj2 = new THREE.Mesh(geom.clone(), basicMaterial1);
              obj3 = new THREE.Line(helpers.geometryToline(geom.clone()), dashMaterial, THREE.LinePieces);
              obj4 = new THREE.Mesh(geom.clone(), wireFrameMaterial);
              renderSubElementsHelper.add(obj2);
              renderSubElementsHelper.add(obj3);
              renderSubElementsHelper.add(obj4);
              child.add(renderSubElementsHelper);
              child.renderSubElementsHelper = renderSubElementsHelper;
            }
        }
        _ref = child.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          subchild = _ref[_i];
          if (subchild.name !== "renderSubs" && subchild.name !== "connectors") {
            _results.push(applyStyle(subchild));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      if (this.assembly != null) {
        _ref = this.assembly.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          _results.push(applyStyle(child));
        }
        return _results;
      }
    };

    return VisualEditorView;

  })(Backbone.Marionette.ItemView);
  return VisualEditorView;
});
