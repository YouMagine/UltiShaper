// Generated by CoffeeScript 1.6.2
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(function(require) {
  var Arrow, BaseHelper, BoundingCage, Grid, LabeledAxes, SelectionHelper, THREE, captureScreen, geometryToline, merge, utils;

  THREE = require('three');
  utils = require('core/utils/utils');
  merge = utils.merge;
  BaseHelper = (function(_super) {
    __extends(BaseHelper, _super);

    function BaseHelper(options) {
      this.drawText2 = __bind(this.drawText2, this);
      this.drawTextOnPlane = __bind(this.drawTextOnPlane, this);
      this.drawText = __bind(this.drawText, this);      BaseHelper.__super__.constructor.call(this, options);
    }

    BaseHelper.prototype.drawText = function(text, displaySize) {
      var canvas, context, size, sprite, spriteMaterial, texture;

      canvas = document.createElement('canvas');
      size = 256;
      displaySize = displaySize || size;
      canvas.width = size;
      canvas.height = size;
      context = canvas.getContext('2d');
      context.font = "17px sans-serif";
      context.textAlign = 'center';
      context.fillStyle = this.textColor;
      context.fillText(text, canvas.width / 2, canvas.height / 2);
      context.strokeStyle = this.textColor;
      context.strokeText(text, canvas.width / 2, canvas.height / 2);
      texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      spriteMaterial = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        alphaTest: 0.5,
        useScreenCoordinates: false,
        scaleByViewport: false,
        color: 0xffffff
      });
      sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(displaySize, displaySize, displaySize);
      return sprite;
    };

    BaseHelper.prototype.drawTextOnPlane = function(text, size) {
      var canvas, context, material, plane, texture;

      if (size == null) {
        size = 256;
      }
      canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      context = canvas.getContext('2d');
      context.font = "17px sans-serif";
      context.textAlign = 'center';
      context.fillStyle = this.textColor;
      context.fillText(text, canvas.width / 2, canvas.height / 2);
      context.strokeStyle = this.textColor;
      context.strokeText(text, canvas.width / 2, canvas.height / 2);
      texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      texture.generateMipmaps = false;
      texture.magFilter = THREE.LinearFilter;
      texture.minFilter = THREE.LinearFilter;
      material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        color: 0xffffff
      });
      plane = new THREE.Mesh(new THREE.PlaneGeometry(size / 8, size / 8), material);
      plane.doubleSided = true;
      plane.overdraw = true;
      return plane;
    };

    BaseHelper.prototype.drawText2 = function(text) {
      var canvas, context, helpersColor, texture;

      helpersColor = this.settings.get("helpersColor");
      if (helpersColor.indexOf("0x" === 0)) {
        helpersColor = "#" + helpersColor.slice(2);
      }
      canvas = document.createElement('canvas');
      context = canvas.getContext('2d');
      context.font = "17px sans-serif";
      context.fillStyle = helpersColor;
      context.fillText(text, 0, 10);
      context.strokeStyle = '#FFFFFF';
      context.strokeText(text, 0, 10);
      texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      return texture;
    };

    return BaseHelper;

  })(THREE.Object3D);
  Arrow = (function(_super) {
    __extends(Arrow, _super);

    function Arrow(options) {
      var defaults, lineGeometry;

      Arrow.__super__.constructor.call(this, options);
      defaults = {
        direction: new THREE.Vector3(1, 0, 0),
        origin: new THREE.Vector3(0, 0, 0),
        length: 50,
        color: "#FF0000"
      };
      options = merge(defaults, options);
      this.direction = options.direction, this.origin = options.origin, this.length = options.length, this.color = options.color;
      lineGeometry = new THREE.Geometry();
      lineGeometry.vertices.push(this.origin);
      lineGeometry.vertices.push(this.direction.setLength(this.length));
      this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({
        color: this.color
      }));
      this.add(this.line);
      this.arrowHeadRootPosition = this.origin.clone().add(this.direction);
      this.arrowHead = new THREE.Mesh(new THREE.CylinderGeometry(0, 1, 5, 10, 10, false), new THREE.MeshBasicMaterial({
        color: this.color
      }));
      this.arrowHead.position = this.arrowHeadRootPosition;
      this.add(this.arrowHead);
    }

    return Arrow;

  })(BaseHelper);
  LabeledAxes = (function(_super) {
    __extends(LabeledAxes, _super);

    function LabeledAxes(options) {
      this._buildAxes = __bind(this._buildAxes, this);
      var addArrows, addLabels, defaults, s;

      LabeledAxes.__super__.constructor.call(this, options);
      defaults = {
        size: 50,
        xColor: "0xFF7700",
        yColor: 0x77FF00,
        zColor: 0x0077FF,
        textColor: "#FFFFFF",
        addLabels: true,
        addArrows: true
      };
      options = merge(defaults, options);
      this.size = options.size, this.xColor = options.xColor, this.yColor = options.yColor, this.zColor = options.zColor, this.textColor = options.textColor, addLabels = options.addLabels, addArrows = options.addArrows;
      this.xColor = new THREE.Color().setHex(this.xColor);
      this.yColor = new THREE.Color().setHex(this.yColor);
      this.zColor = new THREE.Color().setHex(this.zColor);
      if (addLabels) {
        s = this.size * 1.1;
        this.xLabel = this.drawText("X");
        this.xLabel.position.set(s, 0, 0);
        this.yLabel = this.drawText("Y");
        this.yLabel.position.set(0, s, 0);
        this.zLabel = this.drawText("Z");
        this.zLabel.position.set(0, 0, s);
      }
      if (addArrows) {
        s = this.size / 1.25;
        this.xArrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), s, this.xColor);
        this.yArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), s, this.yColor);
        this.zArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), s, this.zColor);
        this.add(this.xArrow);
        this.add(this.yArrow);
        this.add(this.zArrow);
      } else {
        this._buildAxes();
      }
      this.add(this.xLabel);
      this.add(this.yLabel);
      this.add(this.zLabel);
    }

    LabeledAxes.prototype._buildAxes = function() {
      var lineGeometryX, lineGeometryY, lineGeometryZ, xLine, yLine, zLine;

      lineGeometryX = new THREE.Geometry();
      lineGeometryX.vertices.push(new THREE.Vector3(-this.size, 0, 0));
      lineGeometryX.vertices.push(new THREE.Vector3(this.size, 0, 0));
      xLine = new THREE.Line(lineGeometryX, new THREE.LineBasicMaterial({
        color: this.xColor
      }));
      lineGeometryY = new THREE.Geometry();
      lineGeometryY.vertices.push(new THREE.Vector3(0, -this.size, 0));
      lineGeometryY.vertices.push(new THREE.Vector3(0, this.size, 0));
      yLine = new THREE.Line(lineGeometryY, new THREE.LineBasicMaterial({
        color: this.yColor
      }));
      lineGeometryZ = new THREE.Geometry();
      lineGeometryZ.vertices.push(new THREE.Vector3(0, 0, -this.size));
      lineGeometryZ.vertices.push(new THREE.Vector3(0, 0, this.size));
      zLine = new THREE.Line(lineGeometryZ, new THREE.LineBasicMaterial({
        color: this.zColor
      }));
      this.add(xLine);
      this.add(yLine);
      return this.add(zLine);
    };

    return LabeledAxes;

  })(BaseHelper);
  Grid = (function(_super) {
    __extends(Grid, _super);

    function Grid(options) {
      this.setTextLocation = __bind(this.setTextLocation, this);
      this.toggleText = __bind(this.toggleText, this);
      this.setColor = __bind(this.setColor, this);
      this.setOpacity = __bind(this.setOpacity, this);
      var defaults, gridGeometry, gridMaterial, i, mainGridZ, planeFragmentShader, planeGeometry, planeMaterial, subGridGeometry, subGridMaterial, subGridZ, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

      Grid.__super__.constructor.call(this, options);
      defaults = {
        size: 1000,
        step: 100,
        color: 0xFFFFFF,
        opacity: 0.1,
        addText: true,
        textColor: "#FFFFFF",
        textLocation: "f"
      };
      options = merge(defaults, options);
      this.size = options.size, this.step = options.step, this.color = options.color, this.opacity = options.opacity, this.addText = options.addText, this.textColor = options.textColor, this.textLocation = options.textLocation;
      mainGridZ = -0.05;
      gridGeometry = new THREE.Geometry();
      gridMaterial = new THREE.LineBasicMaterial({
        color: new THREE.Color().setHex(this.color),
        opacity: this.opacity,
        linewidth: 2,
        transparent: true
      });
      for (i = _i = _ref = -this.size / 2, _ref1 = this.size / 2, _ref2 = this.step; _ref2 > 0 ? _i <= _ref1 : _i >= _ref1; i = _i += _ref2) {
        gridGeometry.vertices.push(new THREE.Vector3(-this.size / 2, i, mainGridZ));
        gridGeometry.vertices.push(new THREE.Vector3(this.size / 2, i, mainGridZ));
        gridGeometry.vertices.push(new THREE.Vector3(i, -this.size / 2, mainGridZ));
        gridGeometry.vertices.push(new THREE.Vector3(i, this.size / 2, mainGridZ));
      }
      this.mainGrid = new THREE.Line(gridGeometry, gridMaterial, THREE.LinePieces);
      subGridZ = -0.05;
      subGridGeometry = new THREE.Geometry();
      subGridMaterial = new THREE.LineBasicMaterial({
        color: new THREE.Color().setHex(this.color),
        opacity: this.opacity / 2,
        transparent: true
      });
      for (i = _j = _ref3 = -this.size / 2, _ref4 = this.size / 2, _ref5 = this.step / 10; _ref5 > 0 ? _j <= _ref4 : _j >= _ref4; i = _j += _ref5) {
        subGridGeometry.vertices.push(new THREE.Vector3(-this.size / 2, i, subGridZ));
        subGridGeometry.vertices.push(new THREE.Vector3(this.size / 2, i, subGridZ));
        subGridGeometry.vertices.push(new THREE.Vector3(i, -this.size / 2, subGridZ));
        subGridGeometry.vertices.push(new THREE.Vector3(i, this.size / 2, subGridZ));
      }
      this.subGrid = new THREE.Line(subGridGeometry, subGridMaterial, THREE.LinePieces);
      planeGeometry = new THREE.PlaneGeometry(-this.size, this.size, 5, 5);
      planeFragmentShader = ["uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], "void main() {", "gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 );", THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 - shadowColor.x );", "}"].join("\n");
      planeMaterial = new THREE.ShaderMaterial({
        uniforms: THREE.ShaderLib['basic'].uniforms,
        vertexShader: THREE.ShaderLib['basic'].vertexShader,
        fragmentShader: planeFragmentShader,
        color: 0x0000FF,
        transparent: true
      });
      this.plane = new THREE.Mesh(planeGeometry, planeMaterial);
      this.plane.rotation.x = Math.PI;
      this.plane.position.z = -0.3;
      this.plane.name = "workplane";
      this.plane.receiveShadow = true;
      this.add(this.mainGrid);
      this.add(this.subGrid);
      this.add(this.plane);
      this._drawNumbering();
    }

    Grid.prototype._drawNumbering = function() {
      var i, label, sizeLabel, sizeLabel2, xLabelsLeft, xLabelsRight, yLabelsBack, yLabelsFront, _i, _j, _len, _ref, _ref1, _ref2, _ref3;

      if (this.labels != null) {
        this.mainGrid.remove(this.labels);
      }
      this.labels = new THREE.Object3D();
      xLabelsLeft = new THREE.Object3D();
      yLabelsFront = new THREE.Object3D();
      for (i = _i = _ref = -this.size / 2, _ref1 = this.size / 2, _ref2 = this.step; _ref2 > 0 ? _i <= _ref1 : _i >= _ref1; i = _i += _ref2) {
        sizeLabel = this.drawTextOnPlane("" + i, 32);
        sizeLabel2 = sizeLabel.clone();
        sizeLabel.rotation.z = Math.PI / 2;
        sizeLabel.position.set(i, this.size / 2, 0.1);
        xLabelsLeft.add(sizeLabel);
        if (this.textLocation === "center") {
          if (i !== 0) {
            sizeLabel2.position.set(this.size / 2, i, 0.1);
            sizeLabel2.rotation.z = Math.PI / 2;
            yLabelsFront.add(sizeLabel2);
          }
        } else {
          if (i !== this.size / 2 && i !== -this.size / 2) {
            sizeLabel2.position.set(this.size / 2, i, 0.1);
            sizeLabel2.rotation.z = Math.PI / 2;
            yLabelsFront.add(sizeLabel2);
          }
        }
      }
      if (this.textLocation === "center") {
        xLabelsLeft.translateY(-this.size / 2);
        yLabelsFront.translateX(-this.size / 2);
      } else {
        xLabelsRight = xLabelsLeft.clone().translateY(-this.size);
        yLabelsBack = yLabelsFront.clone().translateX(-this.size);
        this.labels.add(xLabelsRight);
        this.labels.add(yLabelsBack);
      }
      this.labels.add(xLabelsLeft);
      this.labels.add(yLabelsFront);
      _ref3 = this.labels.children;
      for (_j = 0, _len = _ref3.length; _j < _len; _j++) {
        label = _ref3[_j];
        label.visible = this.addText;
      }
      return this.mainGrid.add(this.labels);
    };

    Grid.prototype.setOpacity = function(opacity) {
      this.opacity = opacity;
      this.mainGrid.material.opacity = opacity;
      return this.subGrid.material.opacity = opacity;
    };

    Grid.prototype.setColor = function(color) {
      this.color = color;
      this.mainGrid.material.color = new THREE.Color().setHex(this.color);
      return this.subGrid.material.color = new THREE.Color().setHex(this.color);
    };

    Grid.prototype.toggleText = function(toggle) {
      var label, _i, _len, _ref, _results;

      this.addText = toggle;
      _ref = this.labels.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        label = _ref[_i];
        _results.push(label.visible = toggle);
      }
      return _results;
    };

    Grid.prototype.setTextLocation = function(location) {
      this.textLocation = location;
      return this._drawNumbering();
    };

    return Grid;

  })(BaseHelper);
  BoundingCage = (function(_super) {
    __extends(BoundingCage, _super);

    function BoundingCage(options) {
      var bbox, cage, cageGeo, color, defaults, delta, error, height, heightArrow, heightLabel, labelSize, length, lengthArrow, lengthLabel, lineMat, mesh, middlePoint, selectionAxis, v, width, widthArrow, widthLabel;

      BoundingCage.__super__.constructor.call(this, options);
      defaults = {
        mesh: null,
        color: 0xFFFFFF,
        textColor: "#FFFFFF",
        addLabels: true
      };
      options = merge(defaults, options);
      mesh = options.mesh, this.color = options.color, this.textColor = options.textColor, this.addLabels = options.addLabels;
      color = new THREE.Color().setHex(this.color);
      try {
        bbox = mesh.geometry.boundingBox;
        length = bbox.max.x - bbox.min.x;
        width = bbox.max.y - bbox.min.y;
        height = bbox.max.z - bbox.min.z;
        cageGeo = new THREE.CubeGeometry(length, width, height);
        v = function(x, y, z) {
          return new THREE.Vector3(x, y, z);
        };
        /*lineMat = new THREE.LineBasicMaterial
          color: helpersColor
          lineWidth: 2
        */

        lineMat = new THREE.MeshBasicMaterial({
          color: color,
          wireframe: true,
          shading: THREE.FlatShading
        });
        cage = new THREE.Mesh(cageGeo, lineMat);
        middlePoint = function(geometry) {
          var middle;

          middle = new THREE.Vector3();
          middle.x = (geometry.boundingBox.max.x + geometry.boundingBox.min.x) / 2;
          middle.y = (geometry.boundingBox.max.y + geometry.boundingBox.min.y) / 2;
          middle.z = (geometry.boundingBox.max.z + geometry.boundingBox.min.z) / 2;
          return middle;
        };
        delta = middlePoint(mesh.geometry);
        cage.position = delta;
        if (this.addLabels) {
          labelSize = 64;
          widthLabel = this.drawText("w: " + (width.toFixed(2)), labelSize);
          widthLabel.position.set(-length / 2 - 10, 0, height / 2);
          lengthLabel = this.drawText("l: " + (length.toFixed(2)), labelSize);
          lengthLabel.position.set(0, -width / 2 - 10, height / 2);
          heightLabel = this.drawText("h: " + (height.toFixed(2)), labelSize);
          heightLabel.position.set(-length / 2 - 10, -width / 2 - 10, height / 2);
          cage.add(widthLabel);
          cage.add(lengthLabel);
          cage.add(heightLabel);
        }
        widthArrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), width / 2, 0xFF7700);
        lengthArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), length / 2, 0x77FF00);
        heightArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), height / 2, 0x0077FF);
        selectionAxis = new THREE.AxisHelper(Math.min(width, length, height));
        selectionAxis.material.depthTest = false;
        selectionAxis.material.transparent = true;
        selectionAxis.position = mesh.position;
        cage.add(widthArrow);
        cage.add(lengthArrow);
        cage.add(heightArrow);
        mesh.cage = cage;
        mesh.add(cage);
      } catch (_error) {
        error = _error;
      }
    }

    return BoundingCage;

  })(BaseHelper);
  SelectionHelper = (function(_super) {
    __extends(SelectionHelper, _super);

    function SelectionHelper(options) {
      this.highlightObjectAt = __bind(this.highlightObjectAt, this);
      this.selectObjectAt = __bind(this.selectObjectAt, this);
      this.get2DBB = __bind(this.get2DBB, this);
      this._get3DBB = __bind(this._get3DBB, this);
      this._unSelect = __bind(this._unSelect, this);
      this._onSelect = __bind(this._onSelect, this);
      this._unHover = __bind(this._unHover, this);
      this._onHover = __bind(this._onHover, this);
      var defaults;

      SelectionHelper.__super__.constructor.call(this, options);
      defaults = {
        hiearchyRoot: null,
        renderCallback: null,
        camera: null,
        viewWidth: 640,
        viewHeight: 480
      };
      options = merge(defaults, options);
      this.hiearchyRoot = options.hiearchyRoot, this.renderCallback = options.renderCallback, this.camera = options.camera, this.viewWidth = options.viewWidth, this.viewHeight = options.viewHeight;
      this.options = options;
      this.currentHover = null;
      this.currentSelect = null;
      this.selectionColor = 0xCC8888;
      this.projector = new THREE.Projector();
    }

    SelectionHelper.prototype._onHover = function(selection) {
      if (selection != null) {
        this.currentHover = selection;
        selection.currentHoverHex = selection.material.color.getHex();
        selection.material.color.setHex(this.selectionColor);
        return this.renderCallback();
      }
    };

    SelectionHelper.prototype._unHover = function() {
      if (this.currentHover) {
        this.currentHover.material.color.setHex(this.currentHover.currentHoverHex);
        this.currentHover = null;
        return this.renderCallback();
      }
    };

    SelectionHelper.prototype._onSelect = function(selection) {
      this._unHover();
      this.currentSelect = selection;
      new BoundingCage({
        mesh: selection,
        color: this.options.color,
        textColor: this.options.textColor
      });
      selection.currentSelectHex = selection.material.color.getHex();
      selection.material.color.setHex(this.selectionColor);
      return this.renderCallback();
    };

    SelectionHelper.prototype._unSelect = function() {
      var selection;

      if (this.currentSelect) {
        selection = this.currentSelect;
        selection.material.color.setHex(selection.currentSelectHex);
        selection.remove(selection.cage);
        selection.cage = null;
        this.currentSelect = null;
        return this.renderCallback();
      }
      /*
            newMat = new  THREE.MeshLambertMaterial
                color: 0xCC0000
            @currentHover.origMaterial = @currentHover.material
            @currentHover.material = newMat
      */

    };

    SelectionHelper.prototype._get3DBB = function(object) {
      if (object != null) {
        if (object.geometry != null) {
          if (object.geometry.boundingBox != null) {
            return object.geometry.boundingBox;
          } else {
            object.geometry.computeBoundingBox();
            return object.geometry.boundingBox;
          }
        }
      }
      return null;
    };

    SelectionHelper.prototype.get2DBB = function(object, width, height) {
      var bbox3d, centerLeft, centerPercX, centerPercY, centerTop, max3d, maxLeft, maxPercX, maxPercY, maxTop, min3d, minLeft, minPercX, minPercY, minTop, objHeight, objLength, objWidth, pMax, pMin, pos, result;

      if (object != null) {
        bbox3d = this._get3DBB(object);
        min3d = bbox3d.min.clone();
        max3d = bbox3d.max.clone();
        objLength = bbox3d.max.x - bbox3d.min.x;
        objWidth = bbox3d.max.y - bbox3d.min.y;
        objHeight = bbox3d.max.z - bbox3d.min.z;
        pMin = this.projector.projectVector(min3d, this.camera);
        pMax = this.projector.projectVector(max3d, this.camera);
        minPercX = (pMin.x + 1) / 2;
        minPercY = (-pMin.y + 1) / 2;
        minLeft = minPercX * width;
        minTop = minPercY * height;
        maxPercX = (pMax.x + 1) / 2;
        maxPercY = (-pMax.y + 1) / 2;
        maxLeft = maxPercX * width;
        maxTop = maxPercY * height;
        pos = object.position.clone();
        pos = this.projector.projectVector(pos, this.camera);
        centerPercX = (pos.x + 1) / 2;
        centerPercY = (-pos.y + 1) / 2;
        centerLeft = centerPercX * width;
        centerTop = centerPercY * height;
        result = [centerLeft, centerTop, objLength, objWidth, objHeight];
        return result;
      }
    };

    SelectionHelper.prototype.selectObjectAt = function(x, y) {
      var intersects, raycaster, v;

      v = new THREE.Vector3((x / this.viewWidth) * 2 - 1, -(y / this.viewHeight) * 2 + 1, 0.5);
      this.projector.unprojectVector(v, this.camera);
      raycaster = new THREE.Raycaster(this.camera.position, v.sub(this.camera.position).normalize());
      intersects = raycaster.intersectObjects(this.hiearchyRoot, true);
      if (intersects.length > 0) {
        if (intersects[0].object !== this.currentSelect) {
          this._unSelect();
          this._onSelect(intersects[0].object);
          return this.currentSelect;
        }
      } else if (this.currentSelect != null) {
        return this.currentSelect;
      } else {
        return this._unSelect();
      }
    };

    SelectionHelper.prototype.highlightObjectAt = function(x, y) {
      var intersects, raycaster, v;

      v = new THREE.Vector3((x / this.viewWidth) * 2 - 1, -(y / this.viewHeight) * 2 + 1, 0.5);
      this.projector.unprojectVector(v, this.camera);
      raycaster = new THREE.Raycaster(this.camera.position, v.sub(this.camera.position).normalize());
      intersects = raycaster.intersectObjects(this.hiearchyRoot, true);
      if (intersects.length > 0) {
        if (intersects[0].object !== this.currentHover) {
          if (intersects[0].object.name !== "workplane") {
            this._unHover();
            return this._onHover(intersects[0].object);
          }
        }
      } else {
        return this._unHover();
      }
    };

    return SelectionHelper;

  })(BaseHelper);
  captureScreen = function(domElement, width, height) {
    var canvas, ctx, d, img, imgAsDataURL, srcImg,
      _this = this;

    if (width == null) {
      width = 300;
    }
    if (height == null) {
      height = 300;
    }
    if (!domElement) {
      throw new Error("Cannot Do screeshot without canvas domElement");
    }
    srcImg = domElement.toDataURL("image/png");
    canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    ctx = canvas.getContext('2d');
    d = $.Deferred();
    imgAsDataURL = null;
    img = new Image();
    img.onload = function() {
      ctx.drawImage(img, 0, 0, width, height);
      imgAsDataURL = canvas.toDataURL("image/png");
      return d.resolve(imgAsDataURL);
    };
    img.src = srcImg;
    return d;
  };
  geometryToline = function(geo) {
    var a, b, c, d, face, geometry, i, vertices, _i, _ref;

    geometry = new THREE.Geometry();
    vertices = geometry.vertices;
    for (i = _i = 0, _ref = geo.faces.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      face = geo.faces[i];
      if (face instanceof THREE.Face3) {
        a = geo.vertices[face.a].clone();
        b = geo.vertices[face.b].clone();
        c = geo.vertices[face.c].clone();
        vertices.push(a, b, b, c, c, a);
      } else if (face instanceof THREE.Face4) {
        a = geo.vertices[face.a].clone();
        b = geo.vertices[face.b].clone();
        c = geo.vertices[face.c].clone();
        d = geo.vertices[face.d].clone();
        vertices.push(a, b, b, c, c, d, d, a);
      }
    }
    geometry.computeLineDistances();
    return geometry;
  };
  return {
    "LabeledAxes": LabeledAxes,
    "Arrow": Arrow,
    "Grid": Grid,
    "BoundingCage": BoundingCage,
    "SelectionHelper": SelectionHelper,
    "captureScreen": captureScreen,
    "geometryToline": geometryToline
  };
});
